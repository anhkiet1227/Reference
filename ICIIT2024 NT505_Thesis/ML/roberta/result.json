[{"project": "Contract1.sol", "commit_id": "0", "target": 0, "func": "pragma solidity ^0.8.0;\n\ncontract CrossChainDataTransfer {\n    address public sourceChain;\n    mapping(address => string) public transferredData;\n\n    event DataTransferred(address indexed fromChain, address indexed toChain, string data);\n\n    function transferData(address targetChain, string memory newData) public {\n        require(bytes(newData).length > 0, \"Data should not be empty\");\n        require(targetChain != address(0), \"Invalid target chain address\");\n\n        transferredData[targetChain] = newData;\n        emit DataTransferred(sourceChain, targetChain, newData);\n    }\n\n    function setSourceChain() public {\n        sourceChain = msg.sender;\n    }\n\n    function getSourceChain() public view returns (address) {\n        return sourceChain;\n    }\n\n    function getTransferredData(address targetChain) public view returns (string memory) {\n        return transferredData[targetChain];\n    }\n}", "idx": "1"}, {"project": "Contract2.sol", "commit_id": "0", "target": 0, "func": "pragma solidity ^0.8.0;\n\ncontract CrossChainDataTransfer1 {\n    mapping(address => mapping(bytes32 => string)) public transferredData;\n\n    event DataTransferred(address indexed fromChain, address indexed toChain, bytes32 indexed id, string data);\n\n    function transferData(address targetChain, bytes32 id, string memory newData) public {\n        require(bytes(newData).length > 0, \"Data should not be empty\");\n        require(targetChain != address(0), \"Invalid target chain address\");\n\n        transferredData[targetChain][id] = newData;\n        emit DataTransferred(address(this), targetChain, id, newData);\n    }\n\n    function getTransferredData(address fromChain, bytes32 id) public view returns (string memory) {\n        return transferredData[fromChain][id];\n    }\n}", "idx": "2"}, {"project": "Contract3.sol", "commit_id": "0", "target": 0, "func": "pragma solidity ^0.8.0;\n\ncontract CrossChainDataTransferPolkadot {\n    address public polkadotBridgeAddress;\n    \n    event DataTransferred(address indexed fromChain, address indexed toChain, bytes32 indexed id, string data);\n\n    constructor(address _polkadotBridgeAddress) {\n        polkadotBridgeAddress = _polkadotBridgeAddress;\n    }\n\n    function transferData(bytes32 id, string memory newData) public {\n        require(bytes(newData).length > 0, \"Data should not be empty\");\n        Bridge(polkadotBridgeAddress).transferDataToPolkadot(id, newData);\n        emit DataTransferred(address(this), polkadotBridgeAddress, id, newData);\n    }\n}\n\ninterface Bridge {\n    function transferDataToPolkadot(bytes32 id, string memory data) external;\n}", "idx": "3"}, {"project": "Contract4.sol", "commit_id": "0", "target": 0, "func": "pragma solidity ^0.8.0;\n\ncontract CrossChainDataTransferCosmos {\n    address public cosmosBridgeAddress;\n    \n    event DataTransferred(address indexed fromChain, address indexed toChain, bytes32 indexed id, string data);\n\n    constructor(address _cosmosBridgeAddress) {\n        cosmosBridgeAddress = _cosmosBridgeAddress;\n    }\n\n    function transferData(bytes32 id, string memory newData) public {\n        require(bytes(newData).length > 0, \"Data should not be empty\");\n        CosmosBridge(cosmosBridgeAddress).transferDataToCosmos(id, newData);\n        emit DataTransferred(address(this), cosmosBridgeAddress, id, newData);\n    }\n}\n\ninterface CosmosBridge {\n    function transferDataToCosmos(bytes32 id, string memory data) external;\n}", "idx": "4"}, {"project": "Contract5.sol", "commit_id": "0", "target": 0, "func": "pragma solidity ^0.8.0;\n\ncontract CrossChainDataTransferChainlink {\n    address public chainlinkOracleAddress;\n    \n    event DataTransferred(address indexed fromChain, address indexed toChain, bytes32 indexed id, string data);\n\n    constructor(address _chainlinkOracleAddress) {\n        chainlinkOracleAddress = _chainlinkOracleAddress;\n    }\n\n    function transferData(bytes32 id, string memory newData) public {\n        require(bytes(newData).length > 0, \"Data should not be empty\");\n        ChainlinkOracle(chainlinkOracleAddress).requestDataTransfer(id, newData);\n        emit DataTransferred(address(this), chainlinkOracleAddress, id, newData);\n    }\n}\n\ninterface ChainlinkOracle {\n    function requestDataTransfer(bytes32 id, string memory data) external;\n}", "idx": "5"}, {"project": "Contract6.sol", "commit_id": "0", "target": 0, "func": "pragma solidity ^0.8.0;\n\ncontract CrossChainDataTransferMultiBridge {\n    address public bridge1Address;\n    address public bridge2Address;\n    \n    event DataTransferred(address indexed fromChain, address indexed toChain, bytes32 indexed id, string data);\n\n    constructor(address _bridge1Address, address _bridge2Address) {\n        bridge1Address = _bridge1Address;\n        bridge2Address = _bridge2Address;\n    }\n\n    function transferData(bytes32 id, string memory newData) public {\n        require(bytes(newData).length > 0, \"Data should not be empty\");\n        Bridge(bridge1Address).transferData(id, newData);\n        Bridge(bridge2Address).transferData(id, newData);\n        emit DataTransferred(address(this), bridge1Address, id, newData);\n        emit DataTransferred(address(this), bridge2Address, id, newData);\n    }\n}\n\ninterface Bridge {\n    function transferData(bytes32 id, string memory data) external;\n}", "idx": "6"}, {"project": "Contract7.sol", "commit_id": "0", "target": 0, "func": "pragma solidity ^0.8.0;\n\ncontract CrossChainDataTransferAvalanche {\n    address public avalancheBridgeAddress;\n    \n    event DataTransferred(address indexed fromChain, address indexed toChain, bytes32 indexed id, string data);\n\n    constructor(address _avalancheBridgeAddress) {\n        avalancheBridgeAddress = _avalancheBridgeAddress;\n    }\n\n    function transferData(bytes32 id, string memory newData) public {\n        require(bytes(newData).length > 0, \"Data should not be empty\");\n        AvalancheBridge(avalancheBridgeAddress).transferDataToAvalanche(id, newData);\n        emit DataTransferred(address(this), avalancheBridgeAddress, id, newData);\n    }\n}\n\ninterface AvalancheBridge {\n    function transferDataToAvalanche(bytes32 id, string memory data) external;\n}", "idx": "7"}, {"project": "Contract8.sol", "commit_id": "0", "target": 0, "func": "pragma solidity ^0.8.0;\n\ncontract CrossChainDataTransferOracles {\n    address public oracle1Address;\n    address public oracle2Address;\n    \n    event DataTransferred(address indexed fromChain, address indexed toChain, bytes32 indexed id, string data);\n\n    constructor(address _oracle1Address, address _oracle2Address) {\n        oracle1Address = _oracle1Address;\n        oracle2Address = _oracle2Address;\n    }\n\n    function transferData(bytes32 id, string memory newData) public {\n        require(bytes(newData).length > 0, \"Data should not be empty\");\n        Oracle(oracle1Address).requestDataTransfer(id, newData);\n        Oracle(oracle2Address).requestDataTransfer(id, newData);\n        emit DataTransferred(address(this), oracle1Address, id, newData);\n        emit DataTransferred(address(this), oracle2Address, id, newData);\n    }\n}\n\ninterface Oracle {\n    function requestDataTransfer(bytes32 id, string memory data) external;\n}", "idx": "8"}, {"project": "Contract9.sol", "commit_id": "0", "target": 0, "func": "pragma solidity ^0.8.0;\n\ncontract CrossChainDataTransferInterledger {\n    address public interledgerAddress;\n    \n    event DataTransferred(address indexed fromChain, address indexed toChain, bytes32 indexed id, string data);\n\n    constructor(address _interledgerAddress) {\n        interledgerAddress = _interledgerAddress;\n    }\n\n    function transferData(bytes32 id, string memory newData) public {\n        require(bytes(newData).length > 0, \"Data should not be empty\");\n        Interledger(interledgerAddress).transferData(id, newData);\n        emit DataTransferred(address(this), interledgerAddress, id, newData);\n    }\n}\n\ninterface Interledger {\n    function transferData(bytes32 id, string memory data) external;\n}", "idx": "9"}, {"project": "Contract10.sol", "commit_id": "0", "target": 0, "func": "pragma solidity ^0.8.0;\n\ncontract CrossChainDataTransferValidators {\n    address public validator1Address;\n    address public validator2Address;\n    \n    event DataTransferred(address indexed fromChain, address indexed toChain, bytes32 indexed id, string data);\n\n    constructor(address _validator1Address, address _validator2Address) {\n        validator1Address = _validator1Address;\n        validator2Address = _validator2Address;\n    }\n\n    function transferData(bytes32 id, string memory newData) public {\n        require(bytes(newData).length > 0, \"Data should not be empty\");\n        require(Validator(validator1Address).isValid(newData), \"Data not valid\");\n        require(Validator(validator2Address).isValid(newData), \"Data not valid\");\n        emit DataTransferred(address(this), validator1Address, id, newData);\n        emit DataTransferred(address(this), validator2Address, id, newData);\n    }\n}\n\ninterface Validator {\n    function isValid(string memory data) external returns (bool);\n}", "idx": "10"}, {"project": "Contract11.sol", "commit_id": "0", "target": 0, "func": "pragma solidity ^0.8.0;\n\ncontract CrossChainDataTransferMultiSig {\n    address public signer1;\n    address public signer2;\n    \n    event DataTransferred(address indexed fromChain, address indexed toChain, bytes32 indexed id, string data);\n\n    constructor(address _signer1, address _signer2) {\n        signer1 = _signer1;\n        signer2 = _signer2;\n    }\n\n    function transferData(bytes32 id, string memory newData, uint8 v1, bytes32 r1, bytes32 s1, uint8 v2, bytes32 r2, bytes32 s2) public {\n        require(bytes(newData).length > 0, \"Data should not be empty\");\n        require(ecrecover(keccak256(abi.encodePacked(id, newData)), v1, r1, s1) == signer1, \"Invalid signature\");\n        require(ecrecover(keccak256(abi.encodePacked(id, newData)), v2, r2, s2) == signer2, \"Invalid signature\");\n        emit DataTransferred(address(this), address(0), id, newData);\n    }\n}", "idx": "11"}, {"project": "Contract12.sol", "commit_id": "0", "target": 0, "func": "pragma solidity ^0.8.0;\n\ncontract CrossChainDataTransferTimedLock {\n    uint256 public unlockTime;\n    \n    event DataTransferred(address indexed fromChain, address indexed toChain, bytes32 indexed id, string data);\n\n    constructor(uint256 _unlockTime) {\n        unlockTime = _unlockTime;\n    }\n\n    function transferData(bytes32 id, string memory newData) public {\n        require(block.timestamp >= unlockTime, \"Data is still locked\");\n        require(bytes(newData).length > 0, \"Data should not be empty\");\n        emit DataTransferred(address(this), address(0), id, newData);\n    }\n}", "idx": "12"}, {"project": "Contract13.sol", "commit_id": "0", "target": 0, "func": "pragma solidity ^0.8.0;\n\ncontract CrossChainDataTransferHash {\n    mapping(bytes32 => string) public transferredData;\n    \n    event DataTransferred(address indexed fromChain, address indexed toChain, bytes32 indexed id, string data);\n\n    function transferData(bytes32 id, string memory newData) public {\n        require(bytes(newData).length > 0, \"Data should not be empty\");\n        bytes32 dataHash = keccak256(abi.encodePacked(newData));\n        transferredData[dataHash] = newData;\n        emit DataTransferred(address(this), address(0), id, newData);\n    }\n}", "idx": "13"}, {"project": "Contract14.sol", "commit_id": "0", "target": 0, "func": "pragma solidity ^0.8.0;\n\ncontract CrossChainDataTransferEscrow {\n    address public sender;\n    address public receiver;\n    \n    event DataTransferred(address indexed fromChain, address indexed toChain, bytes32 indexed id, string data);\n\n    function initiateTransfer(bytes32 id, address _receiver) public {\n        require(_receiver != address(0), \"Invalid receiver address\");\n        sender = msg.sender;\n        receiver = _receiver;\n        emit DataTransferred(address(this), address(0), id, \"\");\n    }\n\n    function completeTransfer(bytes32 id, string memory newData) public {\n        require(msg.sender == receiver, \"Only receiver can complete the transfer\");\n        require(bytes(newData).length > 0, \"Data should not be empty\");\n        emit DataTransferred(sender, receiver, id, newData);\n    }\n}", "idx": "14"}, {"project": "Contract15.sol", "commit_id": "0", "target": 0, "func": "pragma solidity ^0.8.0;\n\ncontract CrossChainDataTransferQR {\n    mapping(bytes32 => string) public transferredData;\n    \n    event DataTransferred(address indexed fromChain, address indexed toChain, bytes32 indexed id, string data);\n\n    function transferData(bytes32 id, string memory newData, string memory qrCode) public {\n        require(bytes(newData).length > 0, \"Data should not be empty\");\n        require(validateQRCode(qrCode), \"Invalid QR code\");\n        transferredData[id] = newData;\n        emit DataTransferred(address(this), address(0), id, newData);\n    }\n\n    function validateQRCode(string memory qrCode) internal pure returns (bool) {\n        // Simplified QR code validation logic\n        return bytes(qrCode).length > 0;\n    }\n}", "idx": "15"}, {"project": "Contract16.sol", "commit_id": "0", "target": 0, "func": "pragma solidity ^0.8.0;\n\ncontract CrossChainDataTransferGasless {\n    mapping(bytes32 => string) public transferredData;\n    \n    event DataTransferred(address indexed fromChain, address indexed toChain, bytes32 indexed id, string data);\n\n    function transferData(bytes32 id, string memory newData) public {\n        require(bytes(newData).length > 0, \"Data should not be empty\");\n        transferredData[id] = newData;\n        emit DataTransferred(address(this), address(0), id, newData);\n    }\n}", "idx": "16"}, {"project": "Contract17.sol", "commit_id": "0", "target": 0, "func": "pragma solidity ^0.8.0;\n\ncontract CrossChainDataTransferDynamicFormat {\n    mapping(bytes32 => string) public transferredData;\n    mapping(bytes32 => string) public dataFormats;\n    \n    event DataTransferred(address indexed fromChain, address indexed toChain, bytes32 indexed id, string data);\n\n    function transferData(bytes32 id, string memory newData, string memory dataFormat) public {\n        require(bytes(newData).length > 0, \"Data should not be empty\");\n        transferredData[id] = newData;\n        dataFormats[id] = dataFormat;\n        emit DataTransferred(address(this), address(0), id, newData);\n    }\n}", "idx": "17"}, {"project": "Contract18.sol", "commit_id": "0", "target": 0, "func": "pragma solidity ^0.8.0;\n\ncontract CrossChainDataTransfer {\n    struct DataTransfer {\n        address fromChain;\n        address toChain;\n        bytes32 id;\n        string data;\n    }\n\n    DataTransfer[] public dataTransfers;\n\n    event DataTransferred(address indexed fromChain, address indexed toChain, bytes32 indexed id, string data);\n\n    function transferData(address toChain, bytes32 id, string memory newData) public {\n        require(bytes(newData).length > 0, \"Data should not be empty\");\n        \n        DataTransfer memory transfer = DataTransfer({\n            fromChain: address(this),\n            toChain: toChain,\n            id: id,\n            data: newData\n        });\n\n        dataTransfers.push(transfer);\n        emit DataTransferred(address(this), toChain, id, newData);\n    }\n    \n    function getTransferredDataCount() public view returns (uint) {\n        return dataTransfers.length;\n    }\n    \n    function getTransferredData(uint index) public view returns (address, address, bytes32, string memory) {\n        require(index < dataTransfers.length, \"Invalid index\");\n        DataTransfer memory transfer = dataTransfers[index];\n        return (transfer.fromChain, transfer.toChain, transfer.id, transfer.data);\n    }\n}", "idx": "18"}, {"project": "Contract19.sol", "commit_id": "0", "target": 0, "func": "pragma solidity ^0.8.0;\n\ncontract CrossChainDataTransfer3_1 {\n    mapping(address => mapping(bytes32 => string)) public transferredData;\n\n    event DataTransferred(address indexed fromChain, address indexed toChain, bytes32 indexed id, string data);\n\n    function transferData(address targetChain, bytes32 id, string memory newData) public {\n        require(bytes(newData).length > 0, \"Data should not be empty\");\n        require(targetChain != address(0), \"Invalid target chain address\");\n\n        transferredData[targetChain][id] = newData;\n        emit DataTransferred(address(this), targetChain, id, newData);\n    }\n\n    function getTransferredData(address fromChain, bytes32 id) public view returns (string memory) {\n        return transferredData[fromChain][id];\n    }\n}", "idx": "19"}, {"project": "Contract20.sol", "commit_id": "0", "target": 0, "func": "pragma solidity ^0.8.0;\n\ncontract CrossChainDataTransferNew {\n    mapping(address => mapping(bytes32 => string)) public transferredData;\n\n    event DataTransferred(address indexed fromChain, address indexed toChain, bytes32 indexed id, string data);\n\n    function transferData(address targetChain, bytes32 id, string memory newData) public {\n        require(bytes(newData).length > 0, \"Data should not be empty\");\n        require(targetChain != address(0), \"Invalid target chain address\");\n\n        transferredData[targetChain][id] = newData;\n        emit DataTransferred(address(this), targetChain, id, newData);\n    }\n\n    function getTransferredData(address fromChain, bytes32 id) public view returns (string memory) {\n        return transferredData[fromChain][id];\n    }\n}", "idx": "20"}, {"project": "Contract21.sol", "commit_id": "0", "target": 0, "func": "pragma solidity ^0.8.0;\n\ncontract CrossChainDataTransferPolkadot1 {\n    address public polkadotBridgeAddress;\n    \n    event DataTransferred(address indexed fromChain, address indexed toChain, bytes32 indexed id, string data);\n\n    constructor(address _polkadotBridgeAddress) {\n        polkadotBridgeAddress = _polkadotBridgeAddress;\n    }\n\n    function sendDataToPolkadot(bytes32 id, string memory newData) public {\n        require(bytes(newData).length > 0, \"Data should not be empty\");\n        PolkadotBridge(polkadotBridgeAddress).transferDataToPolkadot(id, newData);\n        emit DataTransferred(address(this), polkadotBridgeAddress, id, newData);\n    }\n}\n\ninterface PolkadotBridge {\n    function transferDataToPolkadot(bytes32 id, string memory data) external;\n}", "idx": "21"}, {"project": "Contract22.sol", "commit_id": "0", "target": 0, "func": "pragma solidity ^0.8.0;\n\ncontract CrossChainDataTransferCosmos5 {\n    address public cosmosBridgeAddress;\n    \n    event DataTransferred(address indexed fromChain, address indexed toChain, bytes32 indexed id, string data);\n\n    constructor(address _cosmosBridgeAddress) {\n        cosmosBridgeAddress = _cosmosBridgeAddress;\n    }\n\n    function transferData(bytes32 id, string memory newData) public {\n        require(bytes(newData).length > 0, \"Data should not be empty\");\n        CosmosBridge(cosmosBridgeAddress).transferDataToCosmos(id, newData);\n        emit DataTransferred(address(this), cosmosBridgeAddress, id, newData);\n    }\n}\n\ninterface CosmosBridge {\n    function transferDataToCosmos(bytes32 id, string memory data) external;\n}", "idx": "22"}, {"project": "Contract23.sol", "commit_id": "0", "target": 0, "func": "pragma solidity ^0.8.0;\n\ncontract CrossChainDataTransferPolkadot2 {\n    address public polkadotBridgeAddress;\n    \n    event DataTransferred(address indexed fromChain, address indexed toChain, bytes32 indexed id, string data);\n\n    constructor(address _polkadotBridgeAddress) {\n        polkadotBridgeAddress = _polkadotBridgeAddress;\n    }\n\n    function sendToPolkadot(bytes32 id, string memory newData) public {\n        require(bytes(newData).length > 0, \"Data should not be empty\");\n        PolkadotBridge(polkadotBridgeAddress).transferDataToPolkadot(id, newData);\n        emit DataTransferred(address(this), polkadotBridgeAddress, id, newData);\n    }\n}\n\ninterface PolkadotBridge {\n    function transferDataToPolkadot(bytes32 id, string memory data) external;\n}", "idx": "23"}, {"project": "Contract24.sol", "commit_id": "0", "target": 0, "func": "pragma solidity ^0.8.0;\n\ncontract CrossChainDataTransferPolkadot2 {\n    address public polkadotBridgeAddress;\n    \n    event DataTransferred(address indexed fromChain, address indexed toChain, bytes32 indexed id, string data);\n\n    constructor(address _polkadotBridgeAddress) {\n        polkadotBridgeAddress = _polkadotBridgeAddress;\n    }\n\n    function sendToPolkadot(bytes32 id, string memory newData) public {\n        require(bytes(newData).length > 0, \"Data should not be empty\");\n        PolkadotBridge(polkadotBridgeAddress).transferDataToPolkadot(id, newData);\n        emit DataTransferred(address(this), polkadotBridgeAddress, id, newData);\n    }\n}\n\ninterface PolkadotBridge {\n    function transferDataToPolkadot(bytes32 id, string memory data) external;\n}", "idx": "24"}, {"project": "Contract25.sol", "commit_id": "0", "target": 0, "func": "pragma solidity ^0.8.0;\n\ncontract CrossChainDataTransferPolkadot3 {\n    address public polkadotBridgeAddress;\n    \n    event DataTransferred(address indexed fromChain, address indexed toChain, bytes32 indexed id, string data);\n\n    constructor(address _polkadotBridgeAddress) {\n        polkadotBridgeAddress = _polkadotBridgeAddress;\n    }\n\n    function dispatchToPolkadot(bytes32 id, string memory newData) public {\n        require(bytes(newData).length > 0, \"Data should not be empty\");\n        PolkadotBridge(polkadotBridgeAddress).transferDataToPolkadot(id, newData);\n        emit DataTransferred(address(this), polkadotBridgeAddress, id, newData);\n    }\n}\n\ninterface PolkadotBridge {\n    function transferDataToPolkadot(bytes32 id, string memory data) external;\n}", "idx": "25"}, {"project": "Contract26.sol", "commit_id": "0", "target": 0, "func": "pragma solidity ^0.8.0;\n\ncontract CrossChainDataTransferPolkadot4 {\n    address public polkadotBridgeAddress;\n    \n    event DataTransferred(address indexed fromChain, address indexed toChain, bytes32 indexed id, string data);\n\n    constructor(address _polkadotBridgeAddress) {\n        polkadotBridgeAddress = _polkadotBridgeAddress;\n    }\n\n    function transmitToPolkadot(bytes32 id, string memory newData) public {\n        require(bytes(newData).length > 0, \"Data should not be empty\");\n        PolkadotBridge(polkadotBridgeAddress).transferDataToPolkadot(id, newData);\n        emit DataTransferred(address(this), polkadotBridgeAddress, id, newData);\n    }\n}\n\ninterface PolkadotBridge {\n    function transferDataToPolkadot(bytes32 id, string memory data) external;\n}", "idx": "26"}, {"project": "Contract27.sol", "commit_id": "0", "target": 0, "func": "pragma solidity ^0.8.0;\n\ncontract CrossChainDataTransferPolkadot5 {\n    address public polkadotBridgeAddress;\n    \n    event DataTransferred(address indexed fromChain, address indexed toChain, bytes32 indexed id, string data);\n\n    constructor(address _polkadotBridgeAddress) {\n        polkadotBridgeAddress = _polkadotBridgeAddress;\n    }\n\n    function sendForCrossingToPolkadot(bytes32 id, string memory newData) public {\n        require(bytes(newData).length > 0, \"Data should not be empty\");\n        PolkadotBridge(polkadotBridgeAddress).transferDataToPolkadot(id, newData);\n        emit DataTransferred(address(this), polkadotBridgeAddress, id, newData);\n    }\n}\n\ninterface PolkadotBridge {\n    function transferDataToPolkadot(bytes32 id, string memory data) external;\n}", "idx": "27"}, {"project": "Contract28.sol", "commit_id": "0", "target": 0, "func": "pragma solidity ^0.8.0;\n\ncontract CrossChainDataTransferPolkadot5 {\n    address public polkadotBridgeAddress;\n    \n    event DataTransferred(address indexed fromChain, address indexed toChain, bytes32 indexed id, string data);\n\n    constructor(address _polkadotBridgeAddress) {\n        polkadotBridgeAddress = _polkadotBridgeAddress;\n    }\n\n    function sendForCrossingToPolkadot(bytes32 id, string memory newData) public {\n        require(bytes(newData).length > 0, \"Data should not be empty\");\n        PolkadotBridge(polkadotBridgeAddress).transferDataToPolkadot(id, newData);\n        emit DataTransferred(address(this), polkadotBridgeAddress, id, newData);\n    }\n}\n\ninterface PolkadotBridge {\n    function transferDataToPolkadot(bytes32 id, string memory data) external;\n}", "idx": "28"}, {"project": "Contract29.sol", "commit_id": "0", "target": 0, "func": "pragma solidity ^0.8.0;\n\ncontract CrossChainDataTransferCosmos1 {\n    address public cosmosBridgeAddress;\n    \n    event DataTransferred(address indexed fromChain, address indexed toChain, bytes32 indexed id, string data);\n\n    constructor(address _cosmosBridgeAddress) {\n        cosmosBridgeAddress = _cosmosBridgeAddress;\n    }\n\n    function sendDataToCosmos(bytes32 id, string memory newData) public {\n        require(bytes(newData).length > 0, \"Data should not be empty\");\n        CosmosBridge(cosmosBridgeAddress).transferDataToCosmos(id, newData);\n        emit DataTransferred(address(this), cosmosBridgeAddress, id, newData);\n    }\n}\n\ninterface CosmosBridge {\n    function transferDataToCosmos(bytes32 id, string memory data) external;\n}", "idx": "29"}, {"project": "Contract30.sol", "commit_id": "0", "target": 0, "func": "pragma solidity ^0.8.0;\n\ncontract CrossChainDataTransferCosmos2 {\n    address public cosmosBridgeAddress;\n\n    event CosmosDataSent(address indexed fromChain, address indexed toChain, bytes32 indexed id, string data);\n\n    constructor(address _cosmosBridgeAddress) {\n        cosmosBridgeAddress = _cosmosBridgeAddress;\n    }\n\n    function sendToCosmos(bytes32 id, string memory newData) public {\n        require(bytes(newData).length > 0, \"Data should not be empty\");\n        CosmosBridge(cosmosBridgeAddress).dispatchToCosmos(id, newData);\n        emit CosmosDataSent(address(this), cosmosBridgeAddress, id, newData);\n    }\n}\n\ninterface CosmosBridge {\n    function dispatchToCosmos(bytes32 id, string memory data) external;\n}", "idx": "30"}, {"project": "Contract31.sol", "commit_id": "0", "target": 0, "func": "pragma solidity ^0.8.0;\n\ncontract CrossChainDataTransferCosmos6 {\n    address public cosmosBridgeAddress;\n    \n    event DataTransferred(address indexed fromChain, address indexed toChain, bytes32 indexed id, string data);\n\n    constructor(address _cosmosBridgeAddress) {\n        cosmosBridgeAddress = _cosmosBridgeAddress;\n    }\n\n    function sendToCosmosV2(bytes32 id, string memory newData) public {\n        require(bytes(newData).length > 0, \"Data should not be empty\");\n        CosmosBridge(cosmosBridgeAddress).transferDataToCosmosV2(id, newData);\n        emit DataTransferred(address(this), cosmosBridgeAddress, id, newData);\n    }\n}\n\ninterface CosmosBridge {\n    function transferDataToCosmosV2(bytes32 id, string memory data) external;\n}", "idx": "31"}, {"project": "Contract32.sol", "commit_id": "0", "target": 0, "func": "pragma solidity ^0.8.0;\n\ncontract CrossChainDataTransferPolkadot2 {\n    address public polkadotBridgeAddress;\n\n    event DataTransmitted(address indexed fromChain, address indexed toChain, bytes32 indexed id, string data);\n\n    constructor(address _polkadotBridgeAddress) {\n        polkadotBridgeAddress = _polkadotBridgeAddress;\n    }\n\n    function transmitData(bytes32 id, string memory newData) public {\n        require(bytes(newData).length > 0, \"Data should not be empty\");\n        PolkadotBridge(polkadotBridgeAddress).transmitDataToPolkadot(id, newData);\n        emit DataTransmitted(address(this), polkadotBridgeAddress, id, newData);\n    }\n}\n\ninterface PolkadotBridge {\n    function transmitDataToPolkadot(bytes32 id, string memory data) external;\n}", "idx": "32"}, {"project": "Contract33.sol", "commit_id": "0", "target": 0, "func": "pragma solidity ^0.8.0;\n\ncontract CrossChainDataTransferPolkadot3 {\n    address public polkadotBridgeAddress;\n    mapping(bytes32 => string) private transferredData;\n\n    event DataRelayed(address indexed fromChain, address indexed toChain, bytes32 indexed id, string data);\n\n    constructor(address _polkadotBridgeAddress) {\n        polkadotBridgeAddress = _polkadotBridgeAddress;\n    }\n\n    function relayData(bytes32 id, string memory newData) public {\n        require(bytes(newData).length > 0, \"Data should not be empty\");\n        transferredData[id] = newData;\n        PolkadotBridge(polkadotBridgeAddress).relayDataToPolkadot(id, newData);\n        emit DataRelayed(address(this), polkadotBridgeAddress, id, newData);\n    }\n\n    function getTransferredData(bytes32 id) public view returns (string memory) {\n        return transferredData[id];\n    }\n}\n\ninterface PolkadotBridge {\n    function relayDataToPolkadot(bytes32 id, string memory data) external;\n}", "idx": "33"}, {"project": "Contract34.sol", "commit_id": "0", "target": 0, "func": "pragma solidity ^0.8.0;\n\ncontract CrossChainDataTransferPolkadot4 {\n    address public polkadotBridgeAddress;\n\n    event DataSentToPolkadot(address indexed fromChain, address indexed toChain, bytes32 indexed id, string data);\n\n    constructor(address _polkadotBridgeAddress) {\n        polkadotBridgeAddress = _polkadotBridgeAddress;\n    }\n\n    function sendData(bytes32 id, string memory newData) public {\n        require(bytes(newData).length > 0, \"Data should not be empty\");\n        PolkadotBridge(polkadotBridgeAddress).receiveData(id, newData);\n        emit DataSentToPolkadot(address(this), polkadotBridgeAddress, id, newData);\n    }\n}\n\ninterface PolkadotBridge {\n    function receiveData(bytes32 id, string memory data) external;\n}", "idx": "34"}, {"project": "Contract35.sol", "commit_id": "0", "target": 0, "func": "pragma solidity ^0.8.0;\n\ncontract CrossChainDataTransferPolkadot5 {\n    address public polkadotBridgeAddress;\n\n    event DataForwarded(address indexed fromChain, address indexed toChain, bytes32 indexed id, string data);\n\n    constructor(address _polkadotBridgeAddress) {\n        polkadotBridgeAddress = _polkadotBridgeAddress;\n    }\n\n    function forwardData(bytes32 id, string memory newData) public {\n        require(bytes(newData).length > 0, \"Data should not be empty\");\n        PolkadotBridge(polkadotBridgeAddress).acceptData(id, newData);\n        emit DataForwarded(address(this), polkadotBridgeAddress, id, newData);\n    }\n}\n\ninterface PolkadotBridge {\n    function acceptData(bytes32 id, string memory data) external;\n}", "idx": "35"}, {"project": "Contract36.sol", "commit_id": "0", "target": 0, "func": "pragma solidity ^0.8.0;\n\ncontract CrossChainDataTransferCosmos2 {\n    address public cosmosBridgeAddress;\n\n    event CosmosDataSent(address indexed fromChain, address indexed toChain, bytes32 indexed id, string data);\n\n    constructor(address _cosmosBridgeAddress) {\n        cosmosBridgeAddress = _cosmosBridgeAddress;\n    }\n\n    function sendToCosmos(bytes32 id, string memory newData) public {\n        require(bytes(newData).length > 0, \"Data should not be empty\");\n        CosmosBridge(cosmosBridgeAddress).dispatchToCosmos(id, newData);\n        emit CosmosDataSent(address(this), cosmosBridgeAddress, id, newData);\n    }\n}\n\ninterface CosmosBridge {\n    function dispatchToCosmos(bytes32 id, string memory data) external;\n}", "idx": "36"}, {"project": "Contract37.sol", "commit_id": "0", "target": 0, "func": "pragma solidity ^0.8.0;\n\ncontract CrossChainDataTransferCosmos3 {\n    address public cosmosBridgeAddress;\n\n    event DataRelayedToCosmos(address indexed fromChain, address indexed toChain, bytes32 indexed id, string data);\n\n    constructor(address _cosmosBridgeAddress) {\n        cosmosBridgeAddress = _cosmosBridgeAddress;\n    }\n\n    function relayDataToCosmos(bytes32 id, string memory newData) public {\n        require(bytes(newData).length > 0, \"Data should not be empty\");\n        CosmosBridge(cosmosBridgeAddress).relayToCosmos(id, newData);\n        emit DataRelayedToCosmos(address(this), cosmosBridgeAddress, id, newData);\n    }\n}\n\ninterface CosmosBridge {\n    function relayToCosmos(bytes32 id, string memory data) external;\n}", "idx": "37"}, {"project": "Contract38.sol", "commit_id": "0", "target": 0, "func": "pragma solidity ^0.8.0;\n\ncontract CrossChainDataTransferCosmos4 {\n    address public cosmosBridgeAddress;\n\n    event DataForwardedToCosmos(address indexed fromChain, address indexed toChain, bytes32 indexed id, string data);\n\n    constructor(address _cosmosBridgeAddress) {\n        cosmosBridgeAddress = _cosmosBridgeAddress;\n    }\n\n    function forwardDataToCosmos(bytes32 id, string memory newData) public {\n        require(bytes(newData).length > 0, \"Data should not be empty\");\n        CosmosBridge(cosmosBridgeAddress).forwardToCosmos(id, newData);\n        emit DataForwardedToCosmos(address(this), cosmosBridgeAddress, id, newData);\n    }\n}\n\ninterface CosmosBridge {\n    function forwardToCosmos(bytes32 id, string memory data) external;\n}", "idx": "38"}, {"project": "Contract39.sol", "commit_id": "0", "target": 0, "func": "pragma solidity ^0.8.0;\n\ncontract CrossChainDataTransferCosmos5 {\n    address public cosmosBridgeAddress;\n    mapping(bytes32 => string) private transferredData;\n\n    event CosmosDataDispatched(address indexed fromChain, address indexed toChain, bytes32 indexed id, string data);\n\n    constructor(address _cosmosBridgeAddress) {\n        cosmosBridgeAddress = _cosmosBridgeAddress;\n    }\n\n    function dispatchDataToCosmos(bytes32 id, string memory newData) public {\n        require(bytes(newData).length > 0, \"Data should not be empty\");\n        CosmosBridge(cosmosBridgeAddress).dispatchToCosmos(id, newData);\n        transferredData[id] = newData;\n        emit CosmosDataDispatched(address(this), cosmosBridgeAddress, id, newData);\n    }\n\n    function getTransferredData(bytes32 id) public view returns (string memory) {\n        return transferredData[id];\n    }\n}\n\ninterface CosmosBridge {\n    function dispatchToCosmos(bytes32 id, string memory data) external;\n}", "idx": "39"}, {"project": "Contract40.sol", "commit_id": "0", "target": 0, "func": "pragma solidity ^0.8.0;\n\ncontract CrossChainDataTransferChainlink2 {\n    address public chainlinkOracleAddress;\n\n    event DataSentToChainlink(address indexed fromChain, address indexed toChain, bytes32 indexed id, string data);\n\n    constructor(address _chainlinkOracleAddress) {\n        chainlinkOracleAddress = _chainlinkOracleAddress;\n    }\n\n    function sendDataToChainlink(bytes32 id, string memory newData) public {\n        require(bytes(newData).length > 0, \"Data should not be empty\");\n        ChainlinkOracle(chainlinkOracleAddress).relayData(id, newData);\n        emit DataSentToChainlink(address(this), chainlinkOracleAddress, id, newData);\n    }\n}\n\ninterface ChainlinkOracle {\n    function relayData(bytes32 id, string memory data) external;\n}", "idx": "40"}, {"project": "Contract41.sol", "commit_id": "0", "target": 0, "func": "pragma solidity ^0.8.0;\n\ncontract CrossChainDataTransferChainlink3 {\n    address public chainlinkOracleAddress;\n\n    event DataForwardedToChainlink(address indexed fromChain, address indexed toChain, bytes32 indexed id, string data);\n\n    constructor(address _chainlinkOracleAddress) {\n        chainlinkOracleAddress = _chainlinkOracleAddress;\n    }\n\n    function forwardDataToChainlink(bytes32 id, string memory newData) public {\n        require(bytes(newData).length > 0, \"Data should not be empty\");\n        ChainlinkOracle(chainlinkOracleAddress).dispatchData(id, newData);\n        emit DataForwardedToChainlink(address(this), chainlinkOracleAddress, id, newData);\n    }\n}\n\ninterface ChainlinkOracle {\n    function dispatchData(bytes32 id, string memory data) external;\n}", "idx": "41"}, {"project": "Contract42.sol", "commit_id": "0", "target": 0, "func": "pragma solidity ^0.8.0;\n\ncontract CrossChainDataTransferChainlink4 {\n    address public chainlinkOracleAddress;\n\n    event DataRelayedToChainlink(address indexed fromChain, address indexed toChain, bytes32 indexed id, string data);\n\n    constructor(address _chainlinkOracleAddress) {\n        chainlinkOracleAddress = _chainlinkOracleAddress;\n    }\n\n    function relayDataToChainlink(bytes32 id, string memory newData) public {\n        require(bytes(newData).length > 0, \"Data should not be empty\");\n        ChainlinkOracle(chainlinkOracleAddress).relayToChainlink(id, newData);\n        emit DataRelayedToChainlink(address(this), chainlinkOracleAddress, id, newData);\n    }\n}\n\ninterface ChainlinkOracle {\n    function relayToChainlink(bytes32 id, string memory data) external;\n}", "idx": "42"}, {"project": "Contract43.sol", "commit_id": "0", "target": 0, "func": "pragma solidity ^0.8.0;\n\ncontract CrossChainDataTransferChainlink5 {\n    address public chainlinkOracleAddress;\n\n    event DataTransmittedToChainlink(address indexed fromChain, address indexed toChain, bytes32 indexed id, string data);\n\n    constructor(address _chainlinkOracleAddress) {\n        chainlinkOracleAddress = _chainlinkOracleAddress;\n    }\n\n    function transmitDataToChainlink(bytes32 id, string memory newData) public {\n        require(bytes(newData).length > 0, \"Data should not be empty\");\n        ChainlinkOracle(chainlinkOracleAddress).transmitToChainlink(id, newData);\n        emit DataTransmittedToChainlink(address(this), chainlinkOracleAddress, id, newData);\n    }\n}\n\ninterface ChainlinkOracle {\n    function transmitToChainlink(bytes32 id, string memory data) external;\n}", "idx": "43"}, {"project": "Contract44.sol", "commit_id": "0", "target": 0, "func": "pragma solidity ^0.8.0;\n\ncontract CrossChainDataTransferChainlink6 {\n    address public chainlinkOracleAddress;\n\n    event DataSharedWithChainlink(address indexed fromChain, address indexed toChain, bytes32 indexed id, string data);\n\n    constructor(address _chainlinkOracleAddress) {\n        chainlinkOracleAddress = _chainlinkOracleAddress;\n    }\n\n    function shareDataWithChainlink(bytes32 id, string memory newData) public {\n        require(bytes(newData).length > 0, \"Data should not be empty\");\n        ChainlinkOracle(chainlinkOracleAddress).requestDataTransfer(id, newData);\n        emit DataSharedWithChainlink(address(this), chainlinkOracleAddress, id, newData);\n    }\n}\n\ninterface ChainlinkOracle {\n    function requestDataTransfer(bytes32 id, string memory data) external;\n}", "idx": "44"}, {"project": "Contract45.sol", "commit_id": "0", "target": 0, "func": "pragma solidity ^0.8.0;\n\ncontract CrossChainDataTransferChainlink7 {\n    address public chainlinkOracleAddress;\n\n    event DataDeliveredToChainlink(address indexed fromChain, address indexed toChain, bytes32 indexed id, string data);\n\n    constructor(address _chainlinkOracleAddress) {\n        chainlinkOracleAddress = _chainlinkOracleAddress;\n    }\n\n    function deliverDataToChainlink(bytes32 id, string memory newData) public {\n        require(bytes(newData).length > 0, \"Data should not be empty\");\n        ChainlinkOracle(chainlinkOracleAddress).transmitData(id, newData);\n        emit DataDeliveredToChainlink(address(this), chainlinkOracleAddress, id, newData);\n    }\n}\n\ninterface ChainlinkOracle {\n    function transmitData(bytes32 id, string memory data) external;\n}", "idx": "45"}, {"project": "Contract46.sol", "commit_id": "0", "target": 0, "func": "pragma solidity ^0.8.0;\n\ncontract CrossChainDataTransferChainlink8 {\n    address public chainlinkOracleAddress;\n\n    event DataSentToChainlink(address indexed fromChain, address indexed toChain, bytes32 indexed id, string data);\n\n    constructor(address _chainlinkOracleAddress) {\n        chainlinkOracleAddress = _chainlinkOracleAddress;\n    }\n\n    function sendDataToChainlink(bytes32 id, string memory newData) public {\n        require(bytes(newData).length > 0, \"Data should not be empty\");\n        ChainlinkOracle(chainlinkOracleAddress).relayData(id, newData);\n        emit DataSentToChainlink(address(this), chainlinkOracleAddress, id, newData);\n    }\n}\n\ninterface ChainlinkOracle {\n    function relayData(bytes32 id, string memory data) external;\n}", "idx": "46"}, {"project": "Contract47.sol", "commit_id": "0", "target": 0, "func": "pragma solidity ^0.8.0;\n\ncontract CrossChainDataTransferChainlink9 {\n    address public chainlinkOracleAddress;\n\n    event DataRelayedToChainlink(address indexed fromChain, address indexed toChain, bytes32 indexed id, string data);\n\n    constructor(address _chainlinkOracleAddress) {\n        chainlinkOracleAddress = _chainlinkOracleAddress;\n    }\n\n    function relayDataToChainlink(bytes32 id, string memory newData) public {\n        require(bytes(newData).length > 0, \"Data should not be empty\");\n        ChainlinkOracle(chainlinkOracleAddress).relayToChainlink(id, newData);\n        emit DataRelayedToChainlink(address(this), chainlinkOracleAddress, id, newData);\n    }\n}\n\ninterface ChainlinkOracle {\n    function relayToChainlink(bytes32 id, string memory data) external;\n}", "idx": "47"}, {"project": "Contract48.sol", "commit_id": "0", "target": 0, "func": "pragma solidity ^0.8.0;\n\ncontract CrossChainDataTransferChainlink10 {\n    address public chainlinkOracleAddress;\n\n    event DataSentToChainlink(address indexed fromChain, address indexed toChain, bytes32 indexed id, string data);\n\n    constructor(address _chainlinkOracleAddress) {\n        chainlinkOracleAddress = _chainlinkOracleAddress;\n    }\n\n    function sendDataToChainlink(bytes32 id, string memory newData) public {\n        require(bytes(newData).length > 0, \"Data should not be empty\");\n        ChainlinkOracle(chainlinkOracleAddress).transmitData(id, newData);\n        emit DataSentToChainlink(address(this), chainlinkOracleAddress, id, newData);\n    }\n}\n\ninterface ChainlinkOracle {\n    function transmitData(bytes32 id, string memory data) external;\n}", "idx": "48"}, {"project": "Contract49.sol", "commit_id": "0", "target": 0, "func": "pragma solidity ^0.8.0;\n\ncontract CrossChainDataTransferChainlink11 {\n    address public chainlinkOracleAddress;\n\n    event DataSharedWithChainlink(address indexed fromChain, address indexed toChain, bytes32 indexed id, string data);\n\n    constructor(address _chainlinkOracleAddress) {\n        chainlinkOracleAddress = _chainlinkOracleAddress;\n    }\n\n    function shareDataWithChainlink(bytes32 id, string memory newData) public {\n        require(bytes(newData).length > 0, \"Data should not be empty\");\n        ChainlinkOracle(chainlinkOracleAddress).requestDataTransfer(id, newData);\n        emit DataSharedWithChainlink(address(this), chainlinkOracleAddress, id, newData);\n    }\n}\n\ninterface ChainlinkOracle {\n    function requestDataTransfer(bytes32 id, string memory data) external;\n}", "idx": "49"}, {"project": "Contract50.sol", "commit_id": "0", "target": 0, "func": "pragma solidity ^0.8.0;\n\ncontract CrossChainDataTransferChainlink12 {\n    address public chainlinkOracleAddress;\n\n    event DataDispatchedToChainlink(address indexed fromChain, address indexed toChain, bytes32 indexed id, string data);\n\n    constructor(address _chainlinkOracleAddress) {\n        chainlinkOracleAddress = _chainlinkOracleAddress;\n    }\n\n    function dispatchDataToChainlink(bytes32 id, string memory newData) public {\n        require(bytes(newData).length > 0, \"Data should not be empty\");\n        ChainlinkOracle(chainlinkOracleAddress).transmitToChainlink(id, newData);\n        emit DataDispatchedToChainlink(address(this), chainlinkOracleAddress, id, newData);\n    }\n}\n\ninterface ChainlinkOracle {\n    function transmitToChainlink(bytes32 id, string memory data) external;\n}", "idx": "50"}, {"project": "Contract51.sol", "commit_id": "0", "target": 0, "func": "pragma solidity ^0.8.0;\n\ncontract CrossChainDataTransferMultiBridge3 {\n    address public bridge1Address;\n    address public bridge2Address;\n    address public bridge3Address;\n\n    event DataDispatched(address indexed fromChain, address indexed toChain, bytes32 indexed id, string data);\n\n    constructor(address _bridge1Address, address _bridge2Address, address _bridge3Address) {\n        bridge1Address = _bridge1Address;\n        bridge2Address = _bridge2Address;\n        bridge3Address = _bridge3Address;\n    }\n\n    function dispatchData(bytes32 id, string memory newData) public {\n        require(bytes(newData).length > 0, \"Data should not be empty\");\n        Bridge(bridge1Address).relayData(id, newData);\n        Bridge(bridge2Address).relayData(id, newData);\n        Bridge(bridge3Address).relayData(id, newData);\n        emit DataDispatched(address(this), bridge1Address, id, newData);\n        emit DataDispatched(address(this), bridge2Address, id, newData);\n        emit DataDispatched(address(this), bridge3Address, id, newData);\n    }\n}\n\ninterface Bridge {\n    function relayData(bytes32 id, string memory data) external;\n}", "idx": "51"}, {"project": "Contract52.sol", "commit_id": "0", "target": 0, "func": "pragma solidity ^0.8.0;\n\ncontract CrossChainDataTransferMultiBridge4 {\n    address public bridge1Address;\n    address public bridge2Address;\n\n    event DataSentToBridges(address indexed fromChain, address indexed toChain, bytes32 indexed id, string data);\n\n    constructor(address _bridge1Address, address _bridge2Address) {\n        bridge1Address = _bridge1Address;\n        bridge2Address = _bridge2Address;\n    }\n\n    function sendDataToBridges(bytes32 id, string memory newData) public {\n        require(bytes(newData).length > 0, \"Data should not be empty\");\n        Bridge(bridge1Address).relayData(id, newData);\n        Bridge(bridge2Address).relayData(id, newData);\n        emit DataSentToBridges(address(this), bridge1Address, id, newData);\n        emit DataSentToBridges(address(this), bridge2Address, id, newData);\n    }\n}\n\ninterface Bridge {\n    function relayData(bytes32 id, string memory data) external;\n}", "idx": "52"}, {"project": "Contract53.sol", "commit_id": "0", "target": 0, "func": "pragma solidity ^0.8.0;\n\ncontract CrossChainDataTransferMultiBridge5 {\n    address public bridge1Address;\n    address public bridge2Address;\n\n    event DataForwardedToBridges(address indexed fromChain, address indexed toChain, bytes32 indexed id, string data);\n\n    constructor(address _bridge1Address, address _bridge2Address) {\n        bridge1Address = _bridge1Address;\n        bridge2Address = _bridge2Address;\n    }\n\n    function forwardDataToBridges(bytes32 id, string memory newData) public {\n        require(bytes(newData).length > 0, \"Data should not be empty\");\n        Bridge(bridge1Address).dispatchData(id, newData);\n        Bridge(bridge2Address).dispatchData(id, newData);\n        emit DataForwardedToBridges(address(this), bridge1Address, id, newData);\n        emit DataForwardedToBridges(address(this), bridge2Address, id, newData);\n    }\n}\n\ninterface Bridge {\n    function dispatchData(bytes32 id, string memory data) external;\n}", "idx": "53"}, {"project": "Contract54.sol", "commit_id": "0", "target": 0, "func": "pragma solidity ^0.8.0;\n\ncontract CrossChainDataTransferMultiBridge6 {\n    address public bridge1Address;\n    address public bridge2Address;\n\n    event DataRelayedToBridges(address indexed fromChain, address indexed toChain, bytes32 indexed id, string data);\n\n    constructor(address _bridge1Address, address _bridge2Address) {\n        bridge1Address = _bridge1Address;\n        bridge2Address = _bridge2Address;\n    }\n\n    function relayDataToBridges(bytes32 id, string memory newData) public {\n        require(bytes(newData).length > 0, \"Data should not be empty\");\n        Bridge(bridge1Address).transmitData(id, newData);\n        Bridge(bridge2Address).transmitData(id, newData);\n        emit DataRelayedToBridges(address(this), bridge1Address, id, newData);\n        emit DataRelayedToBridges(address(this), bridge2Address, id, newData);\n    }\n}\n\ninterface Bridge {\n    function transmitData(bytes32 id, string memory data) external;\n}", "idx": "54"}, {"project": "Contract55.sol", "commit_id": "0", "target": 0, "func": "pragma solidity ^0.8.0;\n\ncontract CrossChainDataTransferMultiBridge7 {\n    address public bridge1Address;\n    address public bridge2Address;\n\n    event DataSharedWithBridges(address indexed fromChain, address indexed toChain, bytes32 indexed id, string data);\n\n    constructor(address _bridge1Address, address _bridge2Address) {\n        bridge1Address = _bridge1Address;\n        bridge2Address = _bridge2Address;\n    }\n\n    function shareDataWithBridges(bytes32 id, string memory newData) public {\n        require(bytes(newData).length > 0, \"Data should not be empty\");\n        Bridge(bridge1Address).requestDataTransfer(id, newData);\n        Bridge(bridge2Address).requestDataTransfer(id, newData);\n        emit DataSharedWithBridges(address(this), bridge1Address, id, newData);\n        emit DataSharedWithBridges(address(this), bridge2Address, id, newData);\n    }\n}\n\ninterface Bridge {\n    function requestDataTransfer(bytes32 id, string memory data) external;\n}", "idx": "55"}, {"project": "Contract56.sol", "commit_id": "0", "target": 0, "func": "pragma solidity ^0.8.0;\n\ncontract CrossChainDataTransferMultiBridge8 {\n    address public bridge1Address;\n    address public bridge2Address;\n\n    event DataTransferredToBridges(address indexed fromChain, address indexed toChain, bytes32 indexed id, string data);\n\n    constructor(address _bridge1Address, address _bridge2Address) {\n        bridge1Address = _bridge1Address;\n        bridge2Address = _bridge2Address;\n    }\n\n    function transferDataToBridges(bytes32 id, string memory newData) public {\n        require(bytes(newData).length > 0, \"Data should not be empty\");\n        Bridge(bridge1Address).transferData(id, newData);\n        Bridge(bridge2Address).transferData(id, newData);\n        emit DataTransferredToBridges(address(this), bridge1Address, id, newData);\n        emit DataTransferredToBridges(address(this), bridge2Address, id, newData);\n    }\n}\n\ninterface Bridge {\n    function transferData(bytes32 id, string memory data) external;\n}", "idx": "56"}, {"project": "Contract57.sol", "commit_id": "0", "target": 0, "func": "pragma solidity ^0.8.0;\n\ncontract CrossChainDataTransferAvalanche3 {\n    address public avalancheBridgeAddress;\n\n    event DataTransmittedToAvalanche(address indexed fromChain, address indexed toChain, bytes32 indexed id, string data);\n\n    constructor(address _avalancheBridgeAddress) {\n        avalancheBridgeAddress = _avalancheBridgeAddress;\n    }\n\n    function transmitDataToAvalanche(bytes32 id, string memory newData) public {\n        require(bytes(newData).length > 0, \"Data should not be empty\");\n        AvalancheBridge(avalancheBridgeAddress).transmitData(id, newData);\n        emit DataTransmittedToAvalanche(address(this), avalancheBridgeAddress, id, newData);\n    }\n}\n\ninterface AvalancheBridge {\n    function transmitData(bytes32 id, string memory data) external;\n}", "idx": "57"}, {"project": "Contract58.sol", "commit_id": "0", "target": 0, "func": "pragma solidity ^0.8.0;\n\ncontract CrossChainDataTransferAvalanche4 {\n    address public avalancheBridgeAddress;\n\n    event DataSharedWithAvalanche(address indexed fromChain, address indexed toChain, bytes32 indexed id, string data);\n\n    constructor(address _avalancheBridgeAddress) {\n        avalancheBridgeAddress = _avalancheBridgeAddress;\n    }\n\n    function shareDataWithAvalanche(bytes32 id, string memory newData) public {\n        require(bytes(newData).length > 0, \"Data should not be empty\");\n        AvalancheBridge(avalancheBridgeAddress).requestDataTransfer(id, newData);\n        emit DataSharedWithAvalanche(address(this), avalancheBridgeAddress, id, newData);\n    }\n}\n\ninterface AvalancheBridge {\n    function requestDataTransfer(bytes32 id, string memory data) external;\n}", "idx": "58"}, {"project": "Contract59.sol", "commit_id": "0", "target": 0, "func": "pragma solidity ^0.8.0;\n\ncontract CrossChainDataTransferAvalanche5 {\n    address public avalancheBridgeAddress;\n\n    event DataDeliveredToAvalanche(address indexed fromChain, address indexed toChain, bytes32 indexed id, string data);\n\n    constructor(address _avalancheBridgeAddress) {\n        avalancheBridgeAddress = _avalancheBridgeAddress;\n    }\n\n    function deliverDataToAvalanche(bytes32 id, string memory newData) public {\n        require(bytes(newData).length > 0, \"Data should not be empty\");\n        AvalancheBridge(avalancheBridgeAddress).transmitData(id, newData);\n        emit DataDeliveredToAvalanche(address(this), avalancheBridgeAddress, id, newData);\n    }\n}\n\ninterface AvalancheBridge {\n    function transmitData(bytes32 id, string memory data) external;\n}", "idx": "59"}, {"project": "Contract60.sol", "commit_id": "0", "target": 0, "func": "pragma solidity ^0.8.0;\n\ncontract CrossChainDataTransferAvalanche6 {\n    address public avalancheBridgeAddress;\n\n    event DataRelayedToAvalanche(address indexed fromChain, address indexed toChain, bytes32 indexed id, string data);\n\n    constructor(address _avalancheBridgeAddress) {\n        avalancheBridgeAddress = _avalancheBridgeAddress;\n    }\n\n    function relayDataToAvalanche(bytes32 id, string memory newData) public {\n        require(bytes(newData).length > 0, \"Data should not be empty\");\n        AvalancheBridge(avalancheBridgeAddress).relayData(id, newData);\n        emit DataRelayedToAvalanche(address(this), avalancheBridgeAddress, id, newData);\n    }\n}\n\ninterface AvalancheBridge {\n    function relayData(bytes32 id, string memory data) external;\n}", "idx": "60"}, {"project": "Contract61.sol", "commit_id": "0", "target": 0, "func": "pragma solidity ^0.8.0;\n\ncontract CrossChainDataTransferAvalanche7 {\n    address public avalancheBridgeAddress;\n\n    event DataDispatchedToAvalanche(address indexed fromChain, address indexed toChain, bytes32 indexed id, string data);\n\n    constructor(address _avalancheBridgeAddress) {\n        avalancheBridgeAddress = _avalancheBridgeAddress;\n    }\n\n    function dispatchDataToAvalanche(bytes32 id, string memory newData) public {\n        require(bytes(newData).length > 0, \"Data should not be empty\");\n        AvalancheBridge(avalancheBridgeAddress).transmitData(id, newData);\n        emit DataDispatchedToAvalanche(address(this), avalancheBridgeAddress, id, newData);\n    }\n}\n\ninterface AvalancheBridge {\n    function transmitData(bytes32 id, string memory data) external;\n}", "idx": "61"}, {"project": "Contract62.sol", "commit_id": "0", "target": 0, "func": "pragma solidity ^0.8.0;\n\ncontract CrossChainDataTransferAvalanche8 {\n    address public avalancheBridgeAddress;\n\n    event DataTransmittedToAvalanche(address indexed fromChain, address indexed toChain, bytes32 indexed id, string data);\n\n    constructor(address _avalancheBridgeAddress) {\n        avalancheBridgeAddress = _avalancheBridgeAddress;\n    }\n\n    function transmitDataToAvalanche(bytes32 id, string memory newData) public {\n        require(bytes(newData).length > 0, \"Data should not be empty\");\n        AvalancheBridge(avalancheBridgeAddress).transmitData(id, newData);\n        emit DataTransmittedToAvalanche(address(this), avalancheBridgeAddress, id, newData);\n    }\n}\n\ninterface AvalancheBridge {\n    function transmitData(bytes32 id, string memory data) external;\n}", "idx": "62"}, {"project": "Contract63.sol", "commit_id": "0", "target": 0, "func": "pragma solidity ^0.8.0;\n\ncontract CrossChainDataTransferOracles2 {\n    address public oracle1Address;\n    address public oracle2Address;\n\n    event DataSharedWithOracles(address indexed fromChain, address indexed toChain, bytes32 indexed id, string data);\n\n    constructor(address _oracle1Address, address _oracle2Address) {\n        oracle1Address = _oracle1Address;\n        oracle2Address = _oracle2Address;\n    }\n\n    function shareDataWithOracles(bytes32 id, string memory newData) public {\n        require(bytes(newData).length > 0, \"Data should not be empty\");\n        Oracle(oracle1Address).relayData(id, newData);\n        Oracle(oracle2Address).relayData(id, newData);\n        emit DataSharedWithOracles(address(this), oracle1Address, id, newData);\n        emit DataSharedWithOracles(address(this), oracle2Address, id, newData);\n    }\n}\n\ninterface Oracle {\n    function relayData(bytes32 id, string memory data) external;\n}", "idx": "63"}, {"project": "Contract64.sol", "commit_id": "0", "target": 0, "func": "pragma solidity ^0.8.0;\n\ncontract CrossChainDataTransferOracles4 {\n    address public oracle1Address;\n    address public oracle2Address;\n\n    event DataRelayedToOracles(address indexed fromChain, address indexed toChain, bytes32 indexed id, string data);\n\n    constructor(address _oracle1Address, address _oracle2Address) {\n        oracle1Address = _oracle1Address;\n        oracle2Address = _oracle2Address;\n    }\n\n    function relayDataToOracles(bytes32 id, string memory newData) public {\n        require(bytes(newData).length > 0, \"Data should not be empty\");\n        Oracle(oracle1Address).relayData(id, newData);\n        Oracle(oracle2Address).relayData(id, newData);\n        emit DataRelayedToOracles(address(this), oracle1Address, id, newData);\n        emit DataRelayedToOracles(address(this), oracle2Address, id, newData);\n    }\n}\n\ninterface Oracle {\n    function relayData(bytes32 id, string memory data) external;\n}", "idx": "64"}, {"project": "Contract65.sol", "commit_id": "0", "target": 0, "func": "pragma solidity ^0.8.0;\n\ncontract CrossChainDataTransferOracles5 {\n    address public oracle1Address;\n    address public oracle2Address;\n\n    event DataTransmittedToOracles(address indexed fromChain, address indexed toChain, bytes32 indexed id, string data);\n\n    constructor(address _oracle1Address, address _oracle2Address) {\n        oracle1Address = _oracle1Address;\n        oracle2Address = _oracle2Address;\n    }\n\n    function transmitDataToOracles(bytes32 id, string memory newData) public {\n        require(bytes(newData).length > 0, \"Data should not be empty\");\n        Oracle(oracle1Address).requestDataTransfer(id, newData);\n        Oracle(oracle2Address).requestDataTransfer(id, newData);\n        emit DataTransmittedToOracles(address(this), oracle1Address, id, newData);\n        emit DataTransmittedToOracles(address(this), oracle2Address, id, newData);\n    }\n}\n\ninterface Oracle {\n    function requestDataTransfer(bytes32 id, string memory data) external;\n}", "idx": "65"}, {"project": "Contract66.sol", "commit_id": "0", "target": 0, "func": "pragma solidity ^0.8.0;\n\ncontract CrossChainDataTransferOracles6 {\n    address public oracle1Address;\n    address public oracle2Address;\n\n    event DataDispatchedToOracles(address indexed fromChain, address indexed toChain, bytes32 indexed id, string data);\n\n    constructor(address _oracle1Address, address _oracle2Address) {\n        oracle1Address = _oracle1Address;\n        oracle2Address = _oracle2Address;\n    }\n\n    function dispatchDataToOracles(bytes32 id, string memory newData) public {\n        require(bytes(newData).length > 0, \"Data should not be empty\");\n        Oracle(oracle1Address).relayData(id, newData);\n        Oracle(oracle2Address).relayData(id, newData);\n        emit DataDispatchedToOracles(address(this), oracle1Address, id, newData);\n        emit DataDispatchedToOracles(address(this), oracle2Address, id, newData);\n    }\n}\n\ninterface Oracle {\n    function relayData(bytes32 id, string memory data) external;\n}", "idx": "66"}, {"project": "Contract67.sol", "commit_id": "0", "target": 0, "func": "pragma solidity ^0.8.0;\n\ncontract CrossChainDataTransferOracles7 {\n    address public oracle1Address;\n    address public oracle2Address;\n\n    event DataSentToOracles(address indexed fromChain, address indexed toChain, bytes32 indexed id, string data);\n\n    constructor(address _oracle1Address, address _oracle2Address) {\n        oracle1Address = _oracle1Address;\n        oracle2Address = _oracle2Address;\n    }\n\n    function sendDataToOracles(bytes32 id, string memory newData) public {\n        require(bytes(newData).length > 0, \"Data should not be empty\");\n        Oracle(oracle1Address).relayData(id, newData);\n        Oracle(oracle2Address).relayData(id, newData);\n        emit DataSentToOracles(address(this), oracle1Address, id, newData);\n        emit DataSentToOracles(address(this), oracle2Address, id, newData);\n    }\n}\n\ninterface Oracle {\n    function relayData(bytes32 id, string memory data) external;\n}", "idx": "67"}, {"project": "Contract68.sol", "commit_id": "0", "target": 0, "func": "pragma solidity ^0.8.0;\n\ncontract CrossChainDataTransferOracles8 {\n    address public oracle1Address;\n    address public oracle2Address;\n\n    event DataForwardedToOracles(address indexed fromChain, address indexed toChain, bytes32 indexed id, string data);\n\n    constructor(address _oracle1Address, address _oracle2Address) {\n        oracle1Address = _oracle1Address;\n        oracle2Address = _oracle2Address;\n    }\n\n    function forwardDataToOracles(bytes32 id, string memory newData) public {\n        require(bytes(newData).length > 0, \"Data should not be empty\");\n        Oracle(oracle1Address).relayData(id, newData);\n        Oracle(oracle2Address).relayData(id, newData);\n        emit DataForwardedToOracles(address(this), oracle1Address, id, newData);\n        emit DataForwardedToOracles(address(this), oracle2Address, id, newData);\n    }\n}\n\ninterface Oracle {\n    function relayData(bytes32 id, string memory data) external;\n}", "idx": "68"}, {"project": "Contract69.sol", "commit_id": "0", "target": 0, "func": "pragma solidity ^0.8.0;\n\ncontract CrossChainDataTransferOracles9 {\n    address public oracle1Address;\n    address public oracle2Address;\n\n    event DataPropagatedToOracles(address indexed fromChain, address indexed toChain, bytes32 indexed id, string data);\n\n    constructor(address _oracle1Address, address _oracle2Address) {\n        oracle1Address = _oracle1Address;\n        oracle2Address = _oracle2Address;\n    }\n\n    function propagateDataToOracles(bytes32 id, string memory newData) public {\n        require(bytes(newData).length > 0, \"Data should not be empty\");\n        Oracle(oracle1Address).relayData(id, newData);\n        Oracle(oracle2Address).relayData(id, newData);\n        emit DataPropagatedToOracles(address(this), oracle1Address, id, newData);\n        emit DataPropagatedToOracles(address(this), oracle2Address, id, newData);\n    }\n}\n\ninterface Oracle {\n    function relayData(bytes32 id, string memory data) external;\n}", "idx": "69"}, {"project": "Contract70.sol", "commit_id": "0", "target": 0, "func": "pragma solidity ^0.8.0;\n\ncontract CrossChainDataTransferOracles10 {\n    address public oracle1Address;\n    address public oracle2Address;\n\n    event DataTransmittedToOracles(address indexed fromChain, address indexed toChain, bytes32 indexed id, string data);\n\n    constructor(address _oracle1Address, address _oracle2Address) {\n        oracle1Address = _oracle1Address;\n        oracle2Address = _oracle2Address;\n    }\n\n    function transmitDataToOracles(bytes32 id, string memory newData) public {\n        require(bytes(newData).length > 0, \"Data should not be empty\");\n        Oracle(oracle1Address).relayData(id, newData);\n        Oracle(oracle2Address).relayData(id, newData);\n        emit DataTransmittedToOracles(address(this), oracle1Address, id, newData);\n        emit DataTransmittedToOracles(address(this), oracle2Address, id, newData);\n    }\n}\n\ninterface Oracle {\n    function relayData(bytes32 id, string memory data) external;\n}", "idx": "70"}, {"project": "Contract71.sol", "commit_id": "0", "target": 0, "func": "pragma solidity ^0.8.0;\n\ncontract CrossChainDataTransferOracles11 {\n    address public oracle1Address;\n    address public oracle2Address;\n\n    event DataSentToOracles(address indexed fromChain, address indexed toChain, bytes32 indexed id, string data);\n\n    constructor(address _oracle1Address, address _oracle2Address) {\n        oracle1Address = _oracle1Address;\n        oracle2Address = _oracle2Address;\n    }\n\n    function sendDataToOracles(bytes32 id, string memory newData) public {\n        require(bytes(newData).length > 0, \"Data should not be empty\");\n        Oracle(oracle1Address).relayData(id, newData);\n        Oracle(oracle2Address).relayData(id, newData);\n        emit DataSentToOracles(address(this), oracle1Address, id, newData);\n        emit DataSentToOracles(address(this), oracle2Address, id, newData);\n    }\n}\n\ninterface Oracle {\n    function relayData(bytes32 id, string memory data) external;\n}", "idx": "71"}, {"project": "Contract72.sol", "commit_id": "0", "target": 0, "func": "pragma solidity ^0.8.0;\n\ncontract CrossChainDataTransferOracles12 {\n    address public oracle1Address;\n    address public oracle2Address;\n\n    event DataDispatchedToOracles(address indexed fromChain, address indexed toChain, bytes32 indexed id, string data);\n\n    constructor(address _oracle1Address, address _oracle2Address) {\n        oracle1Address = _oracle1Address;\n        oracle2Address = _oracle2Address;\n    }\n\n    function dispatchDataToOracles(bytes32 id, string memory newData) public {\n        require(bytes(newData).length > 0, \"Data should not be empty\");\n        Oracle(oracle1Address).relayData(id, newData);\n        Oracle(oracle2Address).relayData(id, newData);\n        emit DataDispatchedToOracles(address(this), oracle1Address, id, newData);\n        emit DataDispatchedToOracles(address(this), oracle2Address, id, newData);\n    }\n}\n\ninterface Oracle {\n    function relayData(bytes32 id, string memory data) external;\n}", "idx": "72"}, {"project": "Contract73.sol", "commit_id": "0", "target": 0, "func": "pragma solidity ^0.8.0;\n\ncontract CrossChainDataTransferOracles13 {\n    address public oracle1Address;\n    address public oracle2Address;\n\n    event DataSharedWithOracles(address indexed fromChain, address indexed toChain, bytes32 indexed id, string data);\n\n    constructor(address _oracle1Address, address _oracle2Address) {\n        oracle1Address = _oracle1Address;\n        oracle2Address = _oracle2Address;\n    }\n\n    function shareDataWithOracles(bytes32 id, string memory newData) public {\n        require(bytes(newData).length > 0, \"Data should not be empty\");\n        Oracle(oracle1Address).relayData(id, newData);\n        Oracle(oracle2Address).relayData(id, newData);\n        emit DataSharedWithOracles(address(this), oracle1Address, id, newData);\n        emit DataSharedWithOracles(address(this), oracle2Address, id, newData);\n    }\n}\n\ninterface Oracle {\n    function relayData(bytes32 id, string memory data) external;\n}", "idx": "73"}, {"project": "Contract74.sol", "commit_id": "0", "target": 0, "func": "pragma solidity ^0.8.0;\n\ncontract CrossChainDataTransferOracles14 {\n    address public oracle1Address;\n    address public oracle2Address;\n\n    event DataForwardedToOracles(address indexed fromChain, address indexed toChain, bytes32 indexed id, string data);\n\n    constructor(address _oracle1Address, address _oracle2Address) {\n        oracle1Address = _oracle1Address;\n        oracle2Address = _oracle2Address;\n    }\n\n    function forwardDataToOracles(bytes32 id, string memory newData) public {\n        require(bytes(newData).length > 0, \"Data should not be empty\");\n        Oracle(oracle1Address).relayData(id, newData);\n        Oracle(oracle2Address).relayData(id, newData);\n        emit DataForwardedToOracles(address(this), oracle1Address, id, newData);\n        emit DataForwardedToOracles(address(this), oracle2Address, id, newData);\n    }\n}\n\ninterface Oracle {\n    function relayData(bytes32 id, string memory data) external;\n}", "idx": "74"}, {"project": "Contract75.sol", "commit_id": "0", "target": 0, "func": "pragma solidity ^0.8.0;\n\ncontract InterledgerDataTransfer {\n    address public interledgerAddress;\n\n    event DataRelayed(address indexed fromChain, address indexed toChain, bytes32 indexed id, string data);\n\n    constructor(address _interledgerAddress) {\n        interledgerAddress = _interledgerAddress;\n    }\n\n    function relayDataToInterledger(bytes32 id, string memory newData) public {\n        require(bytes(newData).length > 0, \"Data should not be empty\");\n        Interledger(interledgerAddress).forwardData(id, newData);\n        emit DataRelayed(address(this), interledgerAddress, id, newData);\n    }\n}\n\ninterface Interledger {\n    function forwardData(bytes32 id, string memory data) external;\n}", "idx": "75"}, {"project": "Contract76.sol", "commit_id": "0", "target": 0, "func": "pragma solidity ^0.8.0;\n\ncontract InterledgerDataTransfer2 {\n    address public interledgerAddress;\n\n    event DataSentToInterledger(address indexed fromChain, address indexed toChain, bytes32 indexed id, string data);\n\n    constructor(address _interledgerAddress) {\n        interledgerAddress = _interledgerAddress;\n    }\n\n    function sendDataToInterledger(bytes32 id, string memory newData) public {\n        require(bytes(newData).length > 0, \"Data should not be empty\");\n        Interledger(interledgerAddress).forwardData(id, newData);\n        emit DataSentToInterledger(address(this), interledgerAddress, id, newData);\n    }\n}\n\ninterface Interledger {\n    function forwardData(bytes32 id, string memory data) external;\n}", "idx": "76"}, {"project": "Contract77.sol", "commit_id": "0", "target": 0, "func": "pragma solidity ^0.8.0;\n\ncontract InterledgerDataTransfer3 {\n    address public interledgerAddress;\n\n    event DataDispatchedToInterledger(address indexed fromChain, address indexed toChain, bytes32 indexed id, string data);\n\n    constructor(address _interledgerAddress) {\n        interledgerAddress = _interledgerAddress;\n    }\n\n    function dispatchDataToInterledger(bytes32 id, string memory newData) public {\n        require(bytes(newData).length > 0, \"Data should not be empty\");\n        Interledger(interledgerAddress).forwardData(id, newData);\n        emit DataDispatchedToInterledger(address(this), interledgerAddress, id, newData);\n    }\n}\n\ninterface Interledger {\n    function forwardData(bytes32 id, string memory data) external;\n}", "idx": "77"}, {"project": "Contract78.sol", "commit_id": "0", "target": 0, "func": "pragma solidity ^0.8.0;\n\ncontract InterledgerDataTransfer4 {\n    address public interledgerAddress;\n\n    event DataForwardedToInterledger(address indexed fromChain, address indexed toChain, bytes32 indexed id, string data);\n\n    constructor(address _interledgerAddress) {\n        interledgerAddress = _interledgerAddress;\n    }\n\n    function forwardDataToInterledger(bytes32 id, string memory newData) public {\n        require(bytes(newData).length > 0, \"Data should not be empty\");\n        Interledger(interledgerAddress).forwardData(id, newData);\n        emit DataForwardedToInterledger(address(this), interledgerAddress, id, newData);\n    }\n}\n\ninterface Interledger {\n    function forwardData(bytes32 id, string memory data) external;\n}", "idx": "78"}, {"project": "Contract79.sol", "commit_id": "0", "target": 0, "func": "pragma solidity ^0.8.0;\n\ncontract InterledgerDataTransfer5 {\n    address public interledgerAddress;\n\n    event DataTransferredToInterledger(address indexed fromChain, address indexed toChain, bytes32 indexed id, string data);\n\n    constructor(address _interledgerAddress) {\n        interledgerAddress = _interledgerAddress;\n    }\n\n    function transferDataToInterledger(bytes32 id, string memory newData) public {\n        require(bytes(newData).length > 0, \"Data should not be empty\");\n        Interledger(interledgerAddress).forwardData(id, newData);\n        emit DataTransferredToInterledger(address(this), interledgerAddress, id, newData);\n    }\n}\n\ninterface Interledger {\n    function forwardData(bytes32 id, string memory data) external;\n}", "idx": "79"}, {"project": "Contract80.sol", "commit_id": "0", "target": 0, "func": "pragma solidity ^0.8.0;\n\ncontract InterledgerDataTransfer6 {\n    address public interledgerAddress;\n\n    event DataRelayedToInterledger(address indexed fromChain, address indexed toChain, bytes32 indexed id, string data);\n\n    constructor(address _interledgerAddress) {\n        interledgerAddress = _interledgerAddress;\n    }\n\n    function relayDataToInterledger(bytes32 id, string memory newData) public {\n        require(bytes(newData).length > 0, \"Data should not be empty\");\n        Interledger(interledgerAddress).forwardData(id, newData);\n        emit DataRelayedToInterledger(address(this), interledgerAddress, id, newData);\n    }\n}\n\ninterface Interledger {\n    function forwardData(bytes32 id, string memory data) external;\n}", "idx": "80"}, {"project": "Contract81.sol", "commit_id": "0", "target": 0, "func": "pragma solidity ^0.8.0;\n\ncontract DataTransferWithValidators {\n    address public validator1Address;\n    address public validator2Address;\n\n    event DataTransferredToValidators(address indexed fromChain, address indexed toChain, bytes32 indexed id, string data);\n\n    constructor(address _validator1Address, address _validator2Address) {\n        validator1Address = _validator1Address;\n        validator2Address = _validator2Address;\n    }\n\n    function transferDataToValidators(bytes32 id, string memory newData) public {\n        require(bytes(newData).length > 0, \"Data should not be empty\");\n        require(Validator(validator1Address).isDataValid(newData), \"Data not valid\");\n        require(Validator(validator2Address).isDataValid(newData), \"Data not valid\");\n        emit DataTransferredToValidators(address(this), validator1Address, id, newData);\n        emit DataTransferredToValidators(address(this), validator2Address, id, newData);\n    }\n}\n\ninterface Validator {\n    function isDataValid(string memory data) external returns (bool);\n}", "idx": "81"}, {"project": "Contract82.sol", "commit_id": "0", "target": 0, "func": "pragma solidity ^0.8.0;\n\ncontract DataTransferWithValidators2 {\n    address public validator1Address;\n    address public validator2Address;\n\n    event DataRelayedToValidators(address indexed fromChain, address indexed toChain, bytes32 indexed id, string data);\n\n    constructor(address _validator1Address, address _validator2Address) {\n        validator1Address = _validator1Address;\n        validator2Address = _validator2Address;\n    }\n\n    function relayDataToValidators(bytes32 id, string memory newData) public {\n        require(bytes(newData).length > 0, \"Data should not be empty\");\n        require(Validator(validator1Address).isDataValid(newData), \"Data not valid\");\n        require(Validator(validator2Address).isDataValid(newData), \"Data not valid\");\n        emit DataRelayedToValidators(address(this), validator1Address, id, newData);\n        emit DataRelayedToValidators(address(this), validator2Address, id, newData);\n    }\n}\n\ninterface Validator {\n    function isDataValid(string memory data) external returns (bool);\n}", "idx": "82"}, {"project": "Contract83.sol", "commit_id": "0", "target": 0, "func": "pragma solidity ^0.8.0;\n\ncontract DataTransferWithValidators3 {\n    address public validator1Address;\n    address public validator2Address;\n\n    event DataDispatchedToValidators(address indexed fromChain, address indexed toChain, bytes32 indexed id, string data);\n\n    constructor(address _validator1Address, address _validator2Address) {\n        validator1Address = _validator1Address;\n        validator2Address = _validator2Address;\n    }\n\n    function dispatchDataToValidators(bytes32 id, string memory newData) public {\n        require(bytes(newData).length > 0, \"Data should not be empty\");\n        require(Validator(validator1Address).isDataValid(newData), \"Data not valid\");\n        require(Validator(validator2Address).isDataValid(newData), \"Data not valid\");\n        emit DataDispatchedToValidators(address(this), validator1Address, id, newData);\n        emit DataDispatchedToValidators(address(this), validator2Address, id, newData);\n    }\n}\n\ninterface Validator {\n    function isDataValid(string memory data) external returns (bool);\n}", "idx": "83"}, {"project": "Contract84.sol", "commit_id": "0", "target": 0, "func": "pragma solidity ^0.8.0;\n\ncontract DataTransferWithValidators4 {\n    address public validator1Address;\n    address public validator2Address;\n\n    event DataForwardedToValidators(address indexed fromChain, address indexed toChain, bytes32 indexed id, string data);\n\n    constructor(address _validator1Address, address _validator2Address) {\n        validator1Address = _validator1Address;\n        validator2Address = _validator2Address;\n    }\n\n    function forwardDataToValidators(bytes32 id, string memory newData) public {\n        require(bytes(newData).length > 0, \"Data should not be empty\");\n        require(Validator(validator1Address).isDataValid(newData), \"Data not valid\");\n        require(Validator(validator2Address).isDataValid(newData), \"Data not valid\");\n        emit DataForwardedToValidators(address(this), validator1Address, id, newData);\n        emit DataForwardedToValidators(address(this), validator2Address, id, newData);\n    }\n}\n\ninterface Validator {\n    function isDataValid(string memory data) external returns (bool);\n}", "idx": "84"}, {"project": "Contract85.sol", "commit_id": "0", "target": 0, "func": "pragma solidity ^0.8.0;\n\ncontract DataTransferWithValidators5 {\n    address public validator1Address;\n    address public validator2Address;\n\n    event DataTransmittedToValidators(address indexed fromChain, address indexed toChain, bytes32 indexed id, string data);\n\n    constructor(address _validator1Address, address _validator2Address) {\n        validator1Address = _validator1Address;\n        validator2Address = _validator2Address;\n    }\n\n    function transmitDataToValidators(bytes32 id, string memory newData) public {\n        require(bytes(newData).length > 0, \"Data should not be empty\");\n        require(Validator(validator1Address).isDataValid(newData), \"Data not valid\");\n        require(Validator(validator2Address).isDataValid(newData), \"Data not valid\");\n        emit DataTransmittedToValidators(address(this), validator1Address, id, newData);\n        emit DataTransmittedToValidators(address(this), validator2Address, id, newData);\n    }\n}\n\ninterface Validator {\n    function isDataValid(string memory data) external returns (bool);\n}", "idx": "85"}, {"project": "Contract86.sol", "commit_id": "0", "target": 0, "func": "pragma solidity ^0.8.0;\n\ncontract DataTransferWithValidators6 {\n    address public validator1Address;\n    address public validator2Address;\n\n    event DataPropagatedToValidators(address indexed fromChain, address indexed toChain, bytes32 indexed id, string data);\n\n    constructor(address _validator1Address, address _validator2Address) {\n        validator1Address = _validator1Address;\n        validator2Address = _validator2Address;\n    }\n\n    function propagateDataToValidators(bytes32 id, string memory newData) public {\n        require(bytes(newData).length > 0, \"Data should not be empty\");\n        require(Validator(validator1Address).isDataValid(newData), \"Data not valid\");\n        require(Validator(validator2Address).isDataValid(newData), \"Data not valid\");\n        emit DataPropagatedToValidators(address(this), validator1Address, id, newData);\n        emit DataPropagatedToValidators(address(this), validator2Address, id, newData);\n    }\n}\n\ninterface Validator {\n    function isDataValid(string memory data) external returns (bool);\n}", "idx": "86"}, {"project": "Contract87.sol", "commit_id": "0", "target": 0, "func": "pragma solidity ^0.8.0;\n\ncontract DataTransferWithValidators7 {\n    address public validator1Address;\n    address public validator2Address;\n\n    event DataSentToValidators(address indexed fromChain, address indexed toChain, bytes32 indexed id, string data);\n\n    constructor(address _validator1Address, address _validator2Address) {\n        validator1Address = _validator1Address;\n        validator2Address = _validator2Address;\n    }\n\n    function sendDataToValidators(bytes32 id, string memory newData) public {\n        require(bytes(newData).length > 0, \"Data should not be empty\");\n        require(Validator(validator1Address).isDataValid(newData), \"Data not valid\");\n        require(Validator(validator2Address).isDataValid(newData), \"Data not valid\");\n        emit DataSentToValidators(address(this), validator1Address, id, newData);\n        emit DataSentToValidators(address(this), validator2Address, id, newData);\n    }\n}\n\ninterface Validator {\n    function isDataValid(string memory data) external returns (bool);\n}", "idx": "87"}, {"project": "Contract88.sol", "commit_id": "0", "target": 0, "func": "pragma solidity ^0.8.0;\n\ncontract DataTransferWithValidators8 {\n    address public validator1Address;\n    address public validator2Address;\n\n    event DataDispatchedToValidators(address indexed fromChain, address indexed toChain, bytes32 indexed id, string data);\n\n    constructor(address _validator1Address, address _validator2Address) {\n        validator1Address = _validator1Address;\n        validator2Address = _validator2Address;\n    }\n\n    function dispatchDataToValidators(bytes32 id, string memory newData) public {\n        require(bytes(newData).length > 0, \"Data should not be empty\");\n        require(Validator(validator1Address).isDataValid(newData), \"Data not valid\");\n        require(Validator(validator2Address).isDataValid(newData), \"Data not valid\");\n        emit DataDispatchedToValidators(address(this), validator1Address, id, newData);\n        emit DataDispatchedToValidators(address(this), validator2Address, id, newData);\n    }\n}\n\ninterface Validator {\n    function isDataValid(string memory data) external returns (bool);\n}", "idx": "88"}, {"project": "Contract89.sol", "commit_id": "0", "target": 0, "func": "pragma solidity ^0.8.0;\n\ncontract DataTransferWithValidators9 {\n    address public validator1Address;\n    address public validator2Address;\n\n    event DataForwardedToValidators(address indexed fromChain, address indexed toChain, bytes32 indexed id, string data);\n\n    constructor(address _validator1Address, address _validator2Address) {\n        validator1Address = _validator1Address;\n        validator2Address = _validator2Address;\n    }\n\n    function forwardDataToValidators(bytes32 id, string memory newData) public {\n        require(bytes(newData).length > 0, \"Data should not be empty\");\n        require(Validator(validator1Address).isDataValid(newData), \"Data not valid\");\n        require(Validator(validator2Address).isDataValid(newData), \"Data not valid\");\n        emit DataForwardedToValidators(address(this), validator1Address, id, newData);\n        emit DataForwardedToValidators(address(this), validator2Address, id, newData);\n    }\n}\n\ninterface Validator {\n    function isDataValid(string memory data) external returns (bool);\n}", "idx": "89"}, {"project": "Contract90.sol", "commit_id": "0", "target": 0, "func": "pragma solidity ^0.8.0;\n\ncontract DataTransferWithValidators10 {\n    address public validator1Address;\n    address public validator2Address;\n\n    event DataTransmittedToValidators(address indexed fromChain, address indexed toChain, bytes32 indexed id, string data);\n\n    constructor(address _validator1Address, address _validator2Address) {\n        validator1Address = _validator1Address;\n        validator2Address = _validator2Address;\n    }\n\n    function transmitDataToValidators(bytes32 id, string memory newData) public {\n        require(bytes(newData).length > 0, \"Data should not be empty\");\n        require(Validator(validator1Address).isDataValid(newData), \"Data not valid\");\n        require(Validator(validator2Address).isDataValid(newData), \"Data not valid\");\n        emit DataTransmittedToValidators(address(this), validator1Address, id, newData);\n        emit DataTransmittedToValidators(address(this), validator2Address, id, newData);\n    }\n}\n\ninterface Validator {\n    function isDataValid(string memory data) external returns (bool);\n}", "idx": "90"}, {"project": "Contract91.sol", "commit_id": "0", "target": 0, "func": "pragma solidity ^0.8.0;\n\ncontract CrossChainDataTransferMultiSig2 {\n    address public signer1;\n    address public signer2;\n    \n    event DataMoved(address indexed fromChain, address indexed toChain, bytes32 indexed id, string data);\n\n    constructor(address _signer1, address _signer2) {\n        signer1 = _signer1;\n        signer2 = _signer2;\n    }\n\n    function moveData(bytes32 id, string memory newData, uint8 v1, uint8 v2, bytes32[2] memory rs1, bytes32[2] memory rs2) public {\n        require(bytes(newData).length > 0, \"Data should not be empty\");\n        require(ecrecover(keccak256(abi.encodePacked(id, newData)), v1, rs1[0], rs1[1]) == signer1, \"Invalid signature\");\n        require(ecrecover(keccak256(abi.encodePacked(id, newData)), v2, rs2[0], rs2[1]) == signer2, \"Invalid signature\");\n        emit DataMoved(address(this), address(0), id, newData);\n    }\n}", "idx": "91"}, {"project": "Contract92.sol", "commit_id": "0", "target": 0, "func": "pragma solidity ^0.8.0;\n\ncontract CrossChainDataTransferMultiSig3 {\n    address public signer1;\n    address public signer2;\n    \n    event DataRelayed(address indexed fromChain, address indexed toChain, bytes32 indexed id, string data);\n\n    constructor(address _signer1, address _signer2) {\n        signer1 = _signer1;\n        signer2 = _signer2;\n    }\n\n    function relayData(bytes32 id, string memory newData, uint8 v1, uint8 v2, bytes32 r1, bytes32 s1, bytes32 r2, bytes32 s2) public {\n        require(bytes(newData).length > 0, \"Data should not be empty\");\n        require(ecrecover(keccak256(abi.encodePacked(id, newData)), v1, r1, s1) == signer1, \"Invalid signature\");\n        require(ecrecover(keccak256(abi.encodePacked(id, newData)), v2, r2, s2) == signer2, \"Invalid signature\");\n        emit DataRelayed(address(this), address(0), id, newData);\n    }\n}", "idx": "92"}, {"project": "Contract93.sol", "commit_id": "0", "target": 0, "func": "pragma solidity ^0.8.0;\n\ncontract CrossChainDataTransferMultiSig4 {\n    address public signer1;\n    address public signer2;\n    \n    event DataForwarded(address indexed fromChain, address indexed toChain, bytes32 indexed id, string data);\n\n    constructor(address _signer1, address _signer2) {\n        signer1 = _signer1;\n        signer2 = _signer2;\n    }\n\n    function forwardData(bytes32 id, string memory newData, uint8 v1, uint8 v2, bytes32 r1, bytes32 s1, bytes32 r2, bytes32 s2) public {\n        require(bytes(newData).length > 0, \"Data should not be empty\");\n        require(ecrecover(keccak256(abi.encodePacked(id, newData)), v1, r1, s1) == signer1, \"Invalid signature\");\n        require(ecrecover(keccak256(abi.encodePacked(id, newData)), v2, r2, s2) == signer2, \"Invalid signature\");\n        emit DataForwarded(address(this), address(0), id, newData);\n    }\n}", "idx": "93"}, {"project": "Contract94.sol", "commit_id": "0", "target": 0, "func": "pragma solidity ^0.8.0;\n\ncontract CrossChainDataTransferMultiSig5 {\n    address public signer1;\n    address public signer2;\n    \n    event DataSent(address indexed fromChain, address indexed toChain, bytes32 indexed id, string data);\n\n    constructor(address _signer1, address _signer2) {\n        signer1 = _signer1;\n        signer2 = _signer2;\n    }\n\n    function sendData(bytes32 id, string memory newData, uint8 v1, uint8 v2, bytes32 r1, bytes32 s1, bytes32 r2, bytes32 s2) public {\n        require(bytes(newData).length > 0, \"Data should not be empty\");\n        require(ecrecover(keccak256(abi.encodePacked(id, newData)), v1, r1, s1) == signer1, \"Invalid signature\");\n        require(ecrecover(keccak256(abi.encodePacked(id, newData)), v2, r2, s2) == signer2, \"Invalid signature\");\n        emit DataSent(address(this), address(0), id, newData);\n    }\n}", "idx": "94"}, {"project": "Contract95.sol", "commit_id": "0", "target": 0, "func": "pragma solidity ^0.8.0;\n\ncontract CrossChainDataTransferMultiSig6 {\n    address public signer1;\n    address public signer2;\n    \n    event DataDispatched(address indexed fromChain, address indexed toChain, bytes32 indexed id, string data);\n\n    constructor(address _signer1, address _signer2) {\n        signer1 = _signer1;\n        signer2 = _signer2;\n    }\n\n    function dispatchData(bytes32 id, string memory newData, uint8 v1, uint8 v2, bytes32 r1, bytes32 s1, bytes32 r2, bytes32 s2) public {\n        require(bytes(newData).length > 0, \"Data should not be empty\");\n        require(ecrecover(keccak256(abi.encodePacked(id, newData)), v1, r1, s1) == signer1, \"Invalid signature\");\n        require(ecrecover(keccak256(abi.encodePacked(id, newData)), v2, r2, s2) == signer2, \"Invalid signature\");\n        emit DataDispatched(address(this), address(0), id, newData);\n    }\n}", "idx": "95"}, {"project": "Contract96.sol", "commit_id": "0", "target": 0, "func": "pragma solidity ^0.8.0;\n\ncontract CrossChainDataTransferMultiSig7 {\n    address public signer1;\n    address public signer2;\n    \n    event DataVerified(address indexed fromChain, address indexed toChain, bytes32 indexed id, string data);\n\n    constructor(address _signer1, address _signer2) {\n        signer1 = _signer1;\n        signer2 = _signer2;\n    }\n\n    function verifyData(bytes32 id, string memory newData, uint8 v1, uint8 v2, bytes32 r1, bytes32 s1, bytes32 r2, bytes32 s2) public {\n        require(bytes(newData).length > 0, \"Data should not be empty\");\n        require(ecrecover(keccak256(abi.encodePacked(id, newData)), v1, r1, s1) == signer1, \"Invalid signature\");\n        require(ecrecover(keccak256(abi.encodePacked(id, newData)), v2, r2, s2) == signer2, \"Invalid signature\");\n        emit DataVerified(address(this), address(0), id, newData);\n    }\n}", "idx": "96"}, {"project": "Contract97.sol", "commit_id": "0", "target": 0, "func": "pragma solidity ^0.8.0;\n\ncontract CrossChainDataTransferMultiSig8 {\n    address public signer1;\n    address public signer2;\n    \n    event DataAcknowledged(address indexed fromChain, address indexed toChain, bytes32 indexed id, string data);\n\n    constructor(address _signer1, address _signer2) {\n        signer1 = _signer1;\n        signer2 = _signer2;\n    }\n\n    function acknowledgeData(bytes32 id, string memory newData, uint8 v1, uint8 v2, bytes32 r1, bytes32 s1, bytes32 r2, bytes32 s2) public {\n        require(bytes(newData).length > 0, \"Data should not be empty\");\n        require(ecrecover(keccak256(abi.encodePacked(id, newData)), v1, r1, s1) == signer1, \"Invalid signature\");\n        require(ecrecover(keccak256(abi.encodePacked(id, newData)), v2, r2, s2) == signer2, \"Invalid signature\");\n        emit DataAcknowledged(address(this), address(0), id, newData);\n    }\n}", "idx": "97"}, {"project": "Contract98.sol", "commit_id": "0", "target": 0, "func": "pragma solidity ^0.8.0;\n\ncontract CrossChainDataTransferMultiSig12 {\n    address public signer1;\n    address public signer2;\n    \n    event DataRecorded(address indexed fromChain, address indexed toChain, bytes32 indexed id, string data);\n\n    constructor(address _signer1, address _signer2) {\n        signer1 = _signer1;\n        signer2 = _signer2;\n    }\n\n    function recordData(bytes32 id, string memory newData, uint8 v1, uint8 v2, bytes32 r1, bytes32 s1, bytes32 r2, bytes32 s2) public {\n        require(bytes(newData).length > 0, \"Data should not be empty\");\n        require(ecrecover(keccak256(abi.encodePacked(id, newData)), v1, r1, s1) == signer1, \"Invalid signature\");\n        require(ecrecover(keccak256(abi.encodePacked(id, newData)), v2, r2, s2) == signer2, \"Invalid signature\");\n        emit DataRecorded(address(this), address(0), id, newData);\n    }\n}", "idx": "98"}, {"project": "Contract99.sol", "commit_id": "0", "target": 0, "func": "pragma solidity ^0.8.0;\n\ncontract CrossChainDataTransferMultiSig13 {\n    address public signer1;\n    address public signer2;\n    \n    event DataReceived(address indexed fromChain, address indexed toChain, bytes32 indexed id, string data);\n\n    constructor(address _signer1, address _signer2) {\n        signer1 = _signer1;\n        signer2 = _signer2;\n    }\n\n    function receiveData(bytes32 id, string memory newData, uint8 v1, uint8 v2, bytes32 r1, bytes32 s1, bytes32 r2, bytes32 s2) public {\n        require(bytes(newData).length > 0, \"Data should not be empty\");\n        require(ecrecover(keccak256(abi.encodePacked(id, newData)), v1, r1, s1) == signer1, \"Invalid signature\");\n        require(ecrecover(keccak256(abi.encodePacked(id, newData)), v2, r2, s2) == signer2, \"Invalid signature\");\n        emit DataReceived(address(this), address(0), id, newData);\n    }\n}", "idx": "99"}, {"project": "Contract100.sol", "commit_id": "0", "target": 0, "func": "pragma solidity ^0.8.0;\n\ncontract CrossChainDataTransferMultiSig14 {\n    address public signer1;\n    address public signer2;\n    \n    event DataConfirmedTransfer(address indexed fromChain, address indexed toChain, bytes32 indexed id, string data);\n\n    constructor(address _signer1, address _signer2) {\n        signer1 = _signer1;\n        signer2 = _signer2;\n    }\n\n    function confirmDataTransfer(bytes32 id, string memory newData, uint8 v1, uint8 v2, bytes32 r1, bytes32 s1, bytes32 r2, bytes32 s2) public {\n        require(bytes(newData).length > 0, \"Data should not be empty\");\n        require(ecrecover(keccak256(abi.encodePacked(id, newData)), v1, r1, s1) == signer1, \"Invalid signature\");\n        require(ecrecover(keccak256(abi.encodePacked(id, newData)), v2, r2, s2) == signer2, \"Invalid signature\");\n        emit DataConfirmedTransfer(address(this), address(0), id, newData);\n    }\n}", "idx": "100"}, {"project": "Contract101.sol", "commit_id": "0", "target": 0, "func": "pragma solidity ^0.8.0;\n\ncontract CrossChainDataTransferTimedLock1 {\n    uint256 public unlockTime;\n    \n    event DataUnlocked(address indexed fromChain, address indexed toChain, bytes32 indexed id, string data);\n\n    constructor(uint256 _unlockTime) {\n        unlockTime = _unlockTime;\n    }\n\n    function unlockData(bytes32 id, string memory newData) public {\n        require(block.timestamp >= unlockTime, \"Data is still locked\");\n        require(bytes(newData).length > 0, \"Data should not be empty\");\n        emit DataUnlocked(address(this), address(0), id, newData);\n    }\n}", "idx": "101"}, {"project": "Contract102.sol", "commit_id": "0", "target": 0, "func": "pragma solidity ^0.8.0;\n\ncontract CrossChainDataTransferTimedLock2 {\n    uint256 public unlockTime;\n    \n    event DataUnlocked(address indexed fromChain, address indexed toChain, bytes32 indexed id, string data);\n\n    constructor(uint256 _unlockTime) {\n        unlockTime = _unlockTime;\n    }\n\n    function unlockData(bytes32 id) public {\n        require(block.timestamp >= unlockTime, \"Data is still locked\");\n        emit DataUnlocked(address(this), address(0), id, \"\");\n    }\n}", "idx": "102"}, {"project": "Contract103.sol", "commit_id": "0", "target": 0, "func": "pragma solidity ^0.8.0;\n\ncontract CrossChainDataTransferTimedLock3 {\n    uint256 public unlockTime;\n    \n    event DataTransferred(address indexed fromChain, address indexed toChain, bytes32 indexed id, string data);\n\n    constructor(uint256 _unlockTime) {\n        unlockTime = _unlockTime;\n    }\n\n    function transferData(bytes32 id, string memory newData) public {\n        require(block.timestamp >= unlockTime, \"Data is still locked\");\n        require(bytes(newData).length > 0, \"Data should not be empty\");\n        emit DataTransferred(address(this), address(0), id, newData);\n    }\n}", "idx": "103"}, {"project": "Contract104.sol", "commit_id": "0", "target": 0, "func": "pragma solidity ^0.8.0;\n\ncontract CrossChainDataTransferTimedLock4 {\n    uint256 public unlockTime;\n    \n    event DataTransferred(address indexed fromChain, address indexed toChain, bytes32 indexed id, string data);\n\n    constructor(uint256 _unlockTime) {\n        unlockTime = _unlockTime;\n    }\n\n    function transferData(bytes32 id) public {\n        require(block.timestamp >= unlockTime, \"Data is still locked\");\n        emit DataTransferred(address(this), address(0), id, \"\");\n    }\n}", "idx": "104"}, {"project": "Contract105.sol", "commit_id": "0", "target": 0, "func": "pragma solidity ^0.8.0;\n\ncontract CrossChainDataTransferTimedLock5 {\n    uint256 public unlockTime;\n    \n    event DataReleased(address indexed fromChain, address indexed toChain, bytes32 indexed id, string data);\n\n    constructor(uint256 _unlockTime) {\n        unlockTime = _unlockTime;\n    }\n\n    function releaseData(bytes32 id, string memory newData) public {\n        require(block.timestamp >= unlockTime, \"Data is still locked\");\n        require(bytes(newData).length > 0, \"Data should not be empty\");\n        emit DataReleased(address(this), address(0), id, newData);\n    }\n}", "idx": "105"}, {"project": "Contract106.sol", "commit_id": "0", "target": 0, "func": "pragma solidity ^0.8.0;\n\ncontract CrossChainDataTransferTimedLock6 {\n    uint256 public unlockTime;\n    \n    event DataReleased(address indexed fromChain, address indexed toChain, bytes32 indexed id, string data);\n\n    constructor(uint256 _unlockTime) {\n        unlockTime = _unlockTime;\n    }\n\n    function releaseData(bytes32 id) public {\n        require(block.timestamp >= unlockTime, \"Data is still locked\");\n        emit DataReleased(address(this), address(0), id, \"\");\n    }\n}", "idx": "106"}, {"project": "Contract107.sol", "commit_id": "0", "target": 0, "func": "pragma solidity ^0.8.0;\n\ncontract CrossChainDataTransferTimedLock7 {\n    uint256 public unlockTime;\n    \n    event DataUnlocked(address indexed fromChain, address indexed toChain, bytes32 indexed id, string data);\n\n    constructor(uint256 _unlockTime) {\n        unlockTime = _unlockTime;\n    }\n\n    function unlockData(bytes32 id, string memory newData) public {\n        require(block.timestamp >= unlockTime, \"Data is still locked\");\n        require(bytes(newData).length > 0, \"Data should not be empty\");\n        emit DataUnlocked(address(this), address(0), id, newData);\n    }\n}", "idx": "107"}, {"project": "Contract108.sol", "commit_id": "0", "target": 0, "func": "pragma solidity ^0.8.0;\n\ncontract CrossChainDataTransferTimedLock8 {\n    uint256 public unlockTime;\n    \n    event DataTransferred(address indexed fromChain, address indexed toChain, bytes32 indexed id, string data);\n\n    constructor(uint256 _unlockTime) {\n        unlockTime = _unlockTime;\n    }\n\n    function transferData(bytes32 id) public {\n        require(block.timestamp >= unlockTime, \"Data is still locked\");\n        emit DataTransferred(address(this), address(0), id, \"\");\n    }\n}", "idx": "108"}, {"project": "Contract109.sol", "commit_id": "0", "target": 0, "func": "pragma solidity ^0.8.0;\n\ncontract CrossChainDataTransferTimedLock9 {\n    uint256 public unlockTime;\n    \n    event DataTransferred(address indexed fromChain, address indexed toChain, bytes32 indexed id, string data);\n\n    constructor(uint256 _unlockTime) {\n        unlockTime = _unlockTime;\n    }\n\n    function transferData(bytes32 id, string memory newData) public {\n        require(block.timestamp >= unlockTime, \"Data is still locked\");\n        require(bytes(newData).length > 0, \"Data should not be empty\");\n        emit DataTransferred(address(this), address(0), id, newData);\n    }\n}", "idx": "109"}, {"project": "Contract110.sol", "commit_id": "0", "target": 0, "func": "pragma solidity ^0.8.0;\n\ncontract CrossChainDataTransferTimedLock10 {\n    uint256 public unlockTime;\n    \n    event DataReleased(address indexed fromChain, address indexed toChain, bytes32 indexed id, string data);\n\n    constructor(uint256 _unlockTime) {\n        unlockTime = _unlockTime;\n    }\n\n    function releaseData(bytes32 id) public {\n        require(block.timestamp >= unlockTime, \"Data is still locked\");\n        emit DataReleased(address(this), address(0), id, \"\");\n    }\n}", "idx": "110"}, {"project": "Contract111.sol", "commit_id": "0", "target": 0, "func": "pragma solidity ^0.8.0;\n\ncontract CrossChainDataTransferHash1 {\n    mapping(bytes32 => string) public storedData;\n    \n    event DataStored(address indexed fromChain, address indexed toChain, bytes32 indexed id, string data);\n\n    function storeData(bytes32 id, string memory newData) public {\n        require(bytes(newData).length > 0, \"Data should not be empty\");\n        bytes32 dataHash = keccak256(abi.encodePacked(newData));\n        storedData[dataHash] = newData;\n        emit DataStored(address(this), address(0), id, newData);\n    }\n}", "idx": "111"}, {"project": "Contract112.sol", "commit_id": "0", "target": 0, "func": "pragma solidity ^0.8.0;\n\ncontract CrossChainDataTransferHash2 {\n    mapping(bytes32 => string) public data;\n    \n    event DataReceived(address indexed fromChain, address indexed toChain, bytes32 indexed id, string data);\n\n    function receiveData(bytes32 id, string memory newData) public {\n        require(bytes(newData).length > 0, \"Data should not be empty\");\n        bytes32 dataHash = keccak256(abi.encodePacked(newData));\n        data[dataHash] = newData;\n        emit DataReceived(address(this), address(0), id, newData);\n    }\n}", "idx": "112"}, {"project": "Contract113.sol", "commit_id": "0", "target": 0, "func": "pragma solidity ^0.8.0;\n\ncontract CrossChainDataTransferHash3 {\n    mapping(bytes32 => string) public dataRecords;\n    \n    event DataRecorded(address indexed fromChain, address indexed toChain, bytes32 indexed id, string data);\n\n    function recordData(bytes32 id, string memory newData) public {\n        require(bytes(newData).length > 0, \"Data should not be empty\");\n        bytes32 dataHash = keccak256(abi.encodePacked(newData));\n        dataRecords[dataHash] = newData;\n        emit DataRecorded(address(this), address(0), id, newData);\n    }\n}", "idx": "113"}, {"project": "Contract114.sol", "commit_id": "0", "target": 0, "func": "pragma solidity ^0.8.0;\n\ncontract CrossChainDataTransferHash4 {\n    mapping(bytes32 => string) public dataStore;\n    \n    event DataStored(address indexed fromChain, address indexed toChain, bytes32 indexed id, string data);\n\n    function storeData(bytes32 id, string memory newData) public {\n        require(bytes(newData).length > 0, \"Data should not be empty\");\n        bytes32 dataHash = keccak256(abi.encodePacked(newData));\n        dataStore[dataHash] = newData;\n        emit DataStored(address(this), address(0), id, newData);\n    }\n}", "idx": "114"}, {"project": "Contract115.sol", "commit_id": "0", "target": 0, "func": "pragma solidity ^0.8.0;\n\ncontract CrossChainDataTransferHash5 {\n    mapping(bytes32 => string) public dataCache;\n    \n    event DataCached(address indexed fromChain, address indexed toChain, bytes32 indexed id, string data);\n\n    function cacheData(bytes32 id, string memory newData) public {\n        require(bytes(newData).length > 0, \"Data should not be empty\");\n        bytes32 dataHash = keccak256(abi.encodePacked(newData));\n        dataCache[dataHash] = newData;\n        emit DataCached(address(this), address(0), id, newData);\n    }\n}", "idx": "115"}, {"project": "Contract116.sol", "commit_id": "0", "target": 0, "func": "pragma solidity ^0.8.0;\n\ncontract CrossChainDataTransferHash6 {\n    mapping(bytes32 => string) public dataEntries;\n    \n    event DataStored(address indexed fromChain, address indexed toChain, bytes32 indexed id, string data);\n\n    function storeData(bytes32 id, string memory newData) public {\n        require(bytes(newData).length > 0, \"Data should not be empty\");\n        bytes32 dataHash = keccak256(abi.encodePacked(newData));\n        dataEntries[dataHash] = newData;\n        emit DataStored(address(this), address(0), id, newData);\n    }\n}", "idx": "116"}, {"project": "Contract117.sol", "commit_id": "0", "target": 0, "func": "pragma solidity ^0.8.0;\n\ncontract CrossChainDataTransferHash7 {\n    mapping(bytes32 => string) public hashedData;\n    \n    event DataHashed(address indexed fromChain, address indexed toChain, bytes32 indexed id, string data);\n\n    function hashData(bytes32 id, string memory newData) public {\n        require(bytes(newData).length > 0, \"Data should not be empty\");\n        bytes32 dataHash = keccak256(abi.encodePacked(newData));\n        hashedData[dataHash] = newData;\n        emit DataHashed(address(this), address(0), id, newData);\n    }\n}", "idx": "117"}, {"project": "Contract118.sol", "commit_id": "0", "target": 0, "func": "pragma solidity ^0.8.0;\n\ncontract CrossChainDataTransferHash8 {\n    mapping(bytes32 => string) public storedInfo;\n    \n    event DataStored(address indexed fromChain, address indexed toChain, bytes32 indexed id, string data);\n\n    function storeInfo(bytes32 id, string memory newData) public {\n        require(bytes(newData).length > 0, \"Data should not be empty\");\n        bytes32 dataHash = keccak256(abi.encodePacked(newData));\n        storedInfo[dataHash] = newData;\n        emit DataStored(address(this), address(0), id, newData);\n    }\n}", "idx": "118"}, {"project": "Contract119.sol", "commit_id": "0", "target": 0, "func": "pragma solidity ^0.8.0;\n\ncontract CrossChainDataTransferHash9 {\n    mapping(bytes32 => string) public dataRegistry;\n    \n    event DataStored(address indexed fromChain, address indexed toChain, bytes32 indexed id, string data);\n\n    function storeData(bytes32 id, string memory newData) public {\n        require(bytes(newData).length > 0, \"Data should not be empty\");\n        bytes32 dataHash = keccak256(abi.encodePacked(newData));\n        dataRegistry[dataHash] = newData;\n        emit DataStored(address(this), address(0), id, newData);\n    }\n}", "idx": "119"}, {"project": "Contract120.sol", "commit_id": "0", "target": 0, "func": "pragma solidity ^0.8.0;\n\ncontract CrossChainDataTransferHash10 {\n    mapping(bytes32 => string) public hashData;\n    \n    event DataStored(address indexed fromChain, address indexed toChain, bytes32 indexed id, string data);\n\n    function storeData(bytes32 id, string memory newData) public {\n        require(bytes(newData).length > 0, \"Data should not be empty\");\n        bytes32 dataHash = keccak256(abi.encodePacked(newData));\n        hashData[dataHash] = newData;\n        emit DataStored(address(this), address(0), id, newData);\n    }\n}", "idx": "120"}, {"project": "Contract121.sol", "commit_id": "0", "target": 0, "func": "pragma solidity ^0.8.0;\n\ncontract CrossChainDataTransferEscrow1 {\n    address public depositor;\n    address public beneficiary;\n    \n    event DataDeposited(address indexed fromChain, address indexed toChain, bytes32 indexed id, string data);\n\n    function depositData(bytes32 id, address _beneficiary) public {\n        require(_beneficiary != address(0), \"Invalid beneficiary address\");\n        depositor = msg.sender;\n        beneficiary = _beneficiary;\n        emit DataDeposited(address(this), address(0), id, \"\");\n    }\n\n    function releaseData(bytes32 id, string memory newData) public {\n        require(msg.sender == beneficiary, \"Only beneficiary can release the data\");\n        require(bytes(newData).length > 0, \"Data should not be empty\");\n        emit DataDeposited(depositor, beneficiary, id, newData);\n    }\n}", "idx": "121"}, {"project": "Contract122.sol", "commit_id": "0", "target": 0, "func": "pragma solidity ^0.8.0;\n\ncontract CrossChainDataTransferEscrow2 {\n    address public depositor;\n    address public payee;\n    \n    event DataDeposited(address indexed fromChain, address indexed toChain, bytes32 indexed id, string data);\n\n    function depositData(bytes32 id, address _payee) public {\n        require(_payee != address(0), \"Invalid payee address\");\n        depositor = msg.sender;\n        payee = _payee;\n        emit DataDeposited(address(this), address(0), id, \"\");\n    }\n\n    function releaseData(bytes32 id, string memory newData) public {\n        require(msg.sender == payee, \"Only payee can release the data\");\n        require(bytes(newData).length > 0, \"Data should not be empty\");\n        emit DataDeposited(depositor, payee, id, newData);\n    }\n}", "idx": "122"}, {"project": "Contract123.sol", "commit_id": "0", "target": 0, "func": "pragma solidity ^0.8.0;\n\ncontract CrossChainDataTransferEscrow3 {\n    address public payer;\n    address public payee;\n    \n    event DataDeposited(address indexed fromChain, address indexed toChain, bytes32 indexed id, string data);\n\n    function depositData(bytes32 id, address _payee) public {\n        require(_payee != address(0), \"Invalid payee address\");\n        payer = msg.sender;\n        payee = _payee;\n        emit DataDeposited(address(this), address(0), id, \"\");\n    }\n\n    function releaseData(bytes32 id, string memory newData) public {\n        require(msg.sender == payee, \"Only payee can release the data\");\n        require(bytes(newData).length > 0, \"Data should not be empty\");\n        emit DataDeposited(payer, payee, id, newData);\n    }\n}", "idx": "123"}, {"project": "Contract124.sol", "commit_id": "0", "target": 0, "func": "pragma solidity ^0.8.0;\n\ncontract CrossChainDataTransferEscrow4 {\n    address public depositor;\n    address public receiver;\n    \n    event DataDeposited(address indexed fromChain, address indexed toChain, bytes32 indexed id, string data);\n\n    function depositData(bytes32 id, address _receiver) public {\n        require(_receiver != address(0), \"Invalid receiver address\");\n        depositor = msg.sender;\n        receiver = _receiver;\n        emit DataDeposited(address(this), address(0), id, \"\");\n    }\n\n    function releaseData(bytes32 id, string memory newData) public {\n        require(msg.sender == receiver, \"Only receiver can release the data\");\n        require(bytes(newData).length > 0, \"Data should not be empty\");\n        emit DataDeposited(depositor, receiver, id, newData);\n    }\n}", "idx": "124"}, {"project": "Contract125.sol", "commit_id": "0", "target": 0, "func": "pragma solidity ^0.8.0;\n\ncontract CrossChainDataTransferEscrow5 {\n    address public depositor;\n    address public receiver;\n    \n    event DataDeposited(address indexed fromChain, address indexed toChain, bytes32 indexed id, string data);\n\n    function depositData(bytes32 id, address _receiver) public {\n        require(_receiver != address(0), \"Invalid receiver address\");\n        depositor = msg.sender;\n        receiver = _receiver;\n        emit DataDeposited(address(this), address(0), id, \"\");\n    }\n\n    function releaseData(bytes32 id, string memory newData) public {\n        require(msg.sender == receiver, \"Only receiver can release the data\");\n        require(bytes(newData).length > 0, \"Data should not be empty\");\n        emit DataDeposited(depositor, receiver, id, newData);\n    }\n}", "idx": "125"}, {"project": "Contract126.sol", "commit_id": "0", "target": 0, "func": "pragma solidity ^0.8.0;\n\ncontract CrossChainDataTransferEscrow6 {\n    address public sender;\n    address public recipient;\n    \n    event DataDeposited(address indexed fromChain, address indexed toChain, bytes32 indexed id, string data);\n\n    function depositData(bytes32 id, address _recipient) public {\n        require(_recipient != address(0), \"Invalid recipient address\");\n        sender = msg.sender;\n        recipient = _recipient;\n        emit DataDeposited(address(this), address(0), id, \"\");\n    }\n\n    function releaseData(bytes32 id, string memory newData) public {\n        require(msg.sender == recipient, \"Only recipient can release the data\");\n        require(bytes(newData).length > 0, \"Data should not be empty\");\n        emit DataDeposited(sender, recipient, id, newData);\n    }\n}", "idx": "126"}, {"project": "Contract127.sol", "commit_id": "0", "target": 0, "func": "pragma solidity ^0.8.0;\n\ncontract CrossChainDataTransferEscrow7 {\n    address public from;\n    address public to;\n    \n    event DataDeposited(address indexed fromChain, address indexed toChain, bytes32 indexed id, string data);\n\n    function depositData(bytes32 id, address _to) public {\n        require(_to != address(0), \"Invalid recipient address\");\n        from = msg.sender;\n        to = _to;\n        emit DataDeposited(address(this), address(0), id, \"\");\n    }\n\n    function releaseData(bytes32 id, string memory newData) public {\n        require(msg.sender == to, \"Only recipient can release the data\");\n        require(bytes(newData).length > 0, \"Data should not be empty\");\n        emit DataDeposited(from, to, id, newData);\n    }\n}", "idx": "127"}, {"project": "Contract128.sol", "commit_id": "0", "target": 0, "func": "pragma solidity ^0.8.0;\n\ncontract CrossChainDataTransferEscrow8 {\n    address public depositor;\n    address public payee;\n    \n    event DataDeposited(address indexed fromChain, address indexed toChain, bytes32 indexed id, string data);\n\n    function depositData(bytes32 id, address _payee) public {\n        require(_payee != address(0), \"Invalid payee address\");\n        depositor = msg.sender;\n        payee = _payee;\n        emit DataDeposited(address(this), address(0), id, \"\");\n    }\n\n    function releaseData(bytes32 id, string memory newData) public {\n        require(msg.sender == payee, \"Only payee can release the data\");\n        require(bytes(newData).length > 0, \"Data should not be empty\");\n        emit DataDeposited(depositor, payee, id, newData);\n    }\n}", "idx": "128"}, {"project": "Contract129.sol", "commit_id": "0", "target": 0, "func": "pragma solidity ^0.8.0;\n\ncontract CrossChainDataTransferEscrow9 {\n    address public payer;\n    address public payee;\n    \n    event DataDeposited(address indexed fromChain, address indexed toChain, bytes32 indexed id, string data);\n\n    function depositData(bytes32 id, address _payee) public {\n        require(_payee != address(0), \"Invalid payee address\");\n        payer = msg.sender;\n        payee = _payee;\n        emit DataDeposited(address(this), address(0), id, \"\");\n    }\n\n    function releaseData(bytes32 id, string memory newData) public {\n        require(msg.sender == payee, \"Only payee can release the data\");\n        require(bytes(newData).length > 0, \"Data should not be empty\");\n        emit DataDeposited(payer, payee, id, newData);\n    }\n}", "idx": "129"}, {"project": "Contract130.sol", "commit_id": "0", "target": 0, "func": "pragma solidity ^0.8.0;\n\ncontract CrossChainDataTransferEscrow10 {\n    address public depositor;\n    address public receiver;\n    \n    event DataDeposited(address indexed fromChain, address indexed toChain, bytes32 indexed id, string data);\n\n    function depositData(bytes32 id, address _receiver) public {\n        require(_receiver != address(0), \"Invalid receiver address\");\n        depositor = msg.sender;\n        receiver = _receiver;\n        emit DataDeposited(address(this), address(0), id, \"\");\n    }\n\n    function releaseData(bytes32 id, string memory newData) public {\n        require(msg.sender == receiver, \"Only receiver can release the data\");\n        require(bytes(newData).length > 0, \"Data should not be empty\");\n        emit DataDeposited(depositor, receiver, id, newData);\n    }\n}", "idx": "130"}, {"project": "Contract131.sol", "commit_id": "0", "target": 0, "func": "pragma solidity ^0.8.0;\n\ncontract CrossChainDataTransferGasless1 {\n    mapping(bytes32 => string) public dataRecords;\n    \n    event DataTransferred(address indexed fromChain, address indexed toChain, bytes32 indexed id, string data);\n\n    function transferData(bytes32 id, string memory newData) public {\n        require(bytes(newData).length > 0, \"Data should not be empty\");\n        dataRecords[id] = newData;\n        emit DataTransferred(address(this), address(0), id, newData);\n    }\n}", "idx": "131"}, {"project": "Contract132.sol", "commit_id": "0", "target": 0, "func": "pragma solidity ^0.8.0;\n\ncontract CrossChainDataTransferGasless2 {\n    mapping(bytes32 => string) public records;\n    \n    event DataTransferred(address indexed fromChain, address indexed toChain, bytes32 indexed id, string data);\n\n    function transferData(bytes32 id, string memory data) public {\n        require(bytes(data).length > 0, \"Data should not be empty\");\n        records[id] = data;\n        emit DataTransferred(address(this), address(0), id, data);\n    }\n}", "idx": "132"}, {"project": "Contract133.sol", "commit_id": "0", "target": 0, "func": "pragma solidity ^0.8.0;\n\ncontract CrossChainDataTransferGasless3 {\n    mapping(bytes32 => string) public dataEntries;\n    \n    event DataTransferred(address indexed fromChain, address indexed toChain, bytes32 indexed id, string data);\n\n    function transferData(bytes32 id, string memory newData) public {\n        require(bytes(newData).length > 0, \"Data should not be empty\");\n        dataEntries[id] = newData;\n        emit DataTransferred(address(this), address(0), id, newData);\n    }\n}", "idx": "133"}, {"project": "Contract134.sol", "commit_id": "0", "target": 0, "func": "pragma solidity ^0.8.0;\n\ncontract CrossChainDataTransferGasless4 {\n    mapping(bytes32 => string) public records;\n    \n    event DataTransferred(address indexed fromChain, address indexed toChain, bytes32 indexed id, string data);\n\n    function transferData(bytes32 id, string memory data) public {\n        require(bytes(data).length > 0, \"Data should not be empty\");\n        records[id] = data;\n        emit DataTransferred(address(this), address(0), id, data);\n    }\n}", "idx": "134"}, {"project": "Contract135.sol", "commit_id": "0", "target": 0, "func": "pragma solidity ^0.8.0;\n\ncontract CrossChainDataTransferGasless5 {\n    mapping(bytes32 => string) public dataStorage;\n    \n    event DataTransferred(address indexed fromChain, address indexed toChain, bytes32 indexed id, string data);\n\n    function transferData(bytes32 id, string memory newData) public {\n        require(bytes(newData).length > 0, \"Data should not be empty\");\n        dataStorage[id] = newData;\n        emit DataTransferred(address(this), address(0), id, newData);\n    }\n}", "idx": "135"}, {"project": "Contract136.sol", "commit_id": "0", "target": 0, "func": "pragma solidity ^0.8.0;\n\ncontract CrossChainDataTransferGasless6 {\n    mapping(bytes32 => string) public dataRecords;\n    \n    event DataTransferred(address indexed fromChain, address indexed toChain, bytes32 indexed id, string data);\n\n    function transferData(bytes32 id, string memory newData) public {\n        require(bytes(newData).length > 0, \"Data should not be empty\");\n        dataRecords[id] = newData;\n        emit DataTransferred(address(this), address(0), id, newData);\n    }\n}", "idx": "136"}, {"project": "Contract137.sol", "commit_id": "0", "target": 0, "func": "pragma solidity ^0.8.0;\n\ncontract CrossChainDataTransferGasless7 {\n    mapping(bytes32 => string) public dataEntries;\n    \n    event DataTransferred(address indexed fromChain, address indexed toChain, bytes32 indexed id, string data);\n\n    function transferData(bytes32 id, string memory newData) public {\n        require(bytes(newData).length > 0, \"Data should not be empty\");\n        dataEntries[id] = newData;\n        emit DataTransferred(address(this), address(0), id, newData);\n    }\n}", "idx": "137"}, {"project": "Contract138.sol", "commit_id": "0", "target": 0, "func": "pragma solidity ^0.8.0;\n\ncontract CrossChainDataTransferGasless8 {\n    mapping(bytes32 => string) public records;\n    \n    event DataTransferred(address indexed fromChain, address indexed toChain, bytes32 indexed id, string data);\n\n    function transferData(bytes32 id, string memory data) public {\n        require(bytes(data).length > 0, \"Data should not be empty\");\n        records[id] = data;\n        emit DataTransferred(address(this), address(0), id, data);\n    }\n}", "idx": "138"}, {"project": "Contract139.sol", "commit_id": "0", "target": 0, "func": "pragma solidity ^0.8.0;\n\ncontract CrossChainDataTransferGasless9 {\n    mapping(bytes32 => string) public dataStorage;\n    \n    event DataTransferred(address indexed fromChain, address indexed toChain, bytes32 indexed id, string data);\n\n    function transferData(bytes32 id, string memory newData) public {\n        require(bytes(newData).length > 0, \"Data should not be empty\");\n        dataStorage[id] = newData;\n        emit DataTransferred(address(this), address(0), id, newData);\n    }\n}", "idx": "139"}, {"project": "Contract140.sol", "commit_id": "0", "target": 0, "func": "pragma solidity ^0.8.0;\n\ncontract CrossChainDataTransferGasless10 {\n    mapping(bytes32 => string) public records;\n    \n    event DataTransferred(address indexed fromChain, address indexed toChain, bytes32 indexed id, string data);\n\n    function transferData(bytes32 id, string memory data) public {\n        require(bytes(data).length > 0, \"Data should not be empty\");\n        records[id] = data;\n        emit DataTransferred(address(this), address(0), id, data);\n    }\n}", "idx": "140"}, {"project": "Contract141.sol", "commit_id": "0", "target": 0, "func": "pragma solidity ^0.8.0;\n\ncontract CrossChainDataTransferDynamicFormat1 {\n    mapping(bytes32 => string) public dataRecords;\n    mapping(bytes32 => string) public dataFormats;\n    \n    event DataTransferred(address indexed fromChain, address indexed toChain, bytes32 indexed id, string data);\n\n    function transferData(bytes32 id, string memory data, string memory format) public {\n        require(bytes(data).length > 0, \"Data should not be empty\");\n        dataRecords[id] = data;\n        dataFormats[id] = format;\n        emit DataTransferred(address(this), address(0), id, data);\n    }\n}", "idx": "141"}, {"project": "Contract142.sol", "commit_id": "0", "target": 0, "func": "pragma solidity ^0.8.0;\n\ncontract CrossChainDataTransferDynamicFormat2 {\n    mapping(bytes32 => string) public storedData;\n    mapping(bytes32 => string) public dataFormats;\n    \n    event DataTransferred(address indexed fromChain, address indexed toChain, bytes32 indexed id, string data);\n\n    function transferData(bytes32 id, string memory data, string memory format) public {\n        require(bytes(data).length > 0, \"Data should not be empty\");\n        storedData[id] = data;\n        dataFormats[id] = format;\n        emit DataTransferred(address(this), address(0), id, data);\n    }\n}", "idx": "142"}, {"project": "Contract143.sol", "commit_id": "0", "target": 0, "func": "pragma solidity ^0.8.0;\n\ncontract CrossChainDataTransferDynamicFormat3 {\n    mapping(bytes32 => string) public dataRecords;\n    mapping(bytes32 => string) public dataFormats;\n    \n    event DataTransferred(address indexed fromChain, address indexed toChain, bytes32 indexed id, string data);\n\n    function transferData(bytes32 id, string memory data, string memory format) public {\n        require(bytes(data).length > 0, \"Data should not be empty\");\n        dataRecords[id] = data;\n        dataFormats[id] = format;\n        emit DataTransferred(address(this), address(0), id, data);\n    }\n}", "idx": "143"}, {"project": "Contract144.sol", "commit_id": "0", "target": 0, "func": "pragma solidity ^0.8.0;\n\ncontract CrossChainDataTransferDynamicFormat4 {\n    mapping(bytes32 => string) public transferredData;\n    mapping(bytes32 => string) public dataFormats;\n    \n    event DataTransferred(address indexed fromChain, address indexed toChain, bytes32 indexed id, string data);\n\n    function transferData(bytes32 id, string memory data, string memory format) public {\n        require(bytes(data).length > 0, \"Data should not be empty\");\n        transferredData[id] = data;\n        dataFormats[id] = format;\n        emit DataTransferred(address(this), address(0), id, data);\n    }\n}", "idx": "144"}, {"project": "Contract145.sol", "commit_id": "0", "target": 0, "func": "pragma solidity ^0.8.0;\n\ncontract CrossChainDataTransferDynamicFormat5 {\n    mapping(bytes32 => string) public storedData;\n    mapping(bytes32 => string) public dataFormats;\n    \n    event DataTransferred(address indexed fromChain, address indexed toChain, bytes32 indexed id, string data);\n\n    function transferData(bytes32 id, string memory data, string memory format) public {\n        require(bytes(data).length > 0, \"Data should not be empty\");\n        storedData[id] = data;\n        dataFormats[id] = format;\n        emit DataTransferred(address(this), address(0), id, data);\n    }\n}", "idx": "145"}, {"project": "Contract146.sol", "commit_id": "0", "target": 0, "func": "pragma solidity ^0.8.0;\n\ncontract CrossChainDataTransferDynamicFormat6 {\n    mapping(bytes32 => string) public storedData;\n    mapping(bytes32 => string) public dataFormats;\n    \n    event DataTransferred(address indexed fromChain, address indexed toChain, bytes32 indexed id, string data);\n\n    function transferData(bytes32 id, string memory data, string memory format) public {\n        require(bytes(data).length > 0, \"Data should not be empty\");\n        storedData[id] = data;\n        dataFormats[id] = format;\n        emit DataTransferred(address(this), address(0), id, data);\n    }\n}", "idx": "146"}, {"project": "Contract147.sol", "commit_id": "0", "target": 0, "func": "pragma solidity ^0.8.0;\n\ncontract CrossChainDataTransferDynamicFormat7 {\n    mapping(bytes32 => string) public records;\n    mapping(bytes32 => string) public dataFormats;\n    \n    event DataTransferred(address indexed fromChain, address indexed toChain, bytes32 indexed id, string data);\n\n    function transferData(bytes32 id, string memory data, string memory format) public {\n        require(bytes(data).length > 0, \"Data should not be empty\");\n        records[id] = data;\n        dataFormats[id] = format;\n        emit DataTransferred(address(this), address(0), id, data);\n    }\n}", "idx": "147"}, {"project": "Contract148.sol", "commit_id": "0", "target": 0, "func": "pragma solidity ^0.8.0;\n\ncontract CrossChainDataTransferDynamicFormat8 {\n    mapping(bytes32 => string) public storedData;\n    mapping(bytes32 => string) public dataFormats;\n    \n    event DataTransferred(address indexed fromChain, address indexed toChain, bytes32 indexed id, string data);\n\n    function transferData(bytes32 id, string memory data, string memory format) public {\n        require(bytes(data).length > 0, \"Data should not be empty\");\n        storedData[id] = data;\n        dataFormats[id] = format;\n        emit DataTransferred(address(this), address(0), id, data);\n    }\n}", "idx": "148"}, {"project": "Contract149.sol", "commit_id": "0", "target": 0, "func": "pragma solidity ^0.8.0;\n\ncontract CrossChainDataTransferDynamicFormat9 {\n    mapping(bytes32 => string) public storedData;\n    mapping(bytes32 => string) public dataFormats;\n    \n    event DataTransferred(address indexed fromChain, address indexed toChain, bytes32 indexed id, string data);\n\n    function transferData(bytes32 id, string memory data, string memory format) public {\n        require(bytes(data).length > 0, \"Data should not be empty\");\n        storedData[id] = data;\n        dataFormats[id] = format;\n        emit DataTransferred(address(this), address(0), id, data);\n    }\n}", "idx": "149"}, {"project": "Contract150.sol", "commit_id": "0", "target": 0, "func": "pragma solidity ^0.8.0;\n\ncontract CrossChainDataTransferDynamicFormat10 {\n    mapping(bytes32 => string) public records;\n    mapping(bytes32 => string) public dataFormats;\n    \n    event DataTransferred(address indexed fromChain, address indexed toChain, bytes32 indexed id, string data);\n\n    function transferData(bytes32 id, string memory data, string memory format) public {\n        require(bytes(data).length > 0, \"Data should not be empty\");\n        records[id] = data;\n        dataFormats[id] = format;\n        emit DataTransferred(address(this), address(0), id, data);\n    }\n}", "idx": "150"}, {"project": "Contract151.sol", "commit_id": "0", "target": 0, "func": "pragma solidity ^0.8.0;\n\ncontract CrossChainDataTransferDynamicFormat11 {\n    mapping(bytes32 => string) public storedData;\n    mapping(bytes32 => string) public dataTypes;\n    \n    event DataTransferred(address indexed fromChain, address indexed toChain, bytes32 indexed id, string data);\n\n    function transferData(bytes32 id, string memory data, string memory dataType) public {\n        require(bytes(data).length > 0, \"Data should not be empty\");\n        storedData[id] = data;\n        dataTypes[id] = dataType;\n        emit DataTransferred(address(this), address(0), id, data);\n    }\n}", "idx": "151"}, {"project": "Contract152.sol", "commit_id": "0", "target": 0, "func": "pragma solidity ^0.8.0;\n\ncontract CrossChainDataTransferDynamicFormat12 {\n    mapping(bytes32 => string) public records;\n    mapping(bytes32 => string) public dataTypes;\n    \n    event DataTransferred(address indexed fromChain, address indexed toChain, bytes32 indexed id, string data);\n\n    function transferData(bytes32 id, string memory data, string memory dataType) public {\n        require(bytes(data).length > 0, \"Data should not be empty\");\n        records[id] = data;\n        dataTypes[id] = dataType;\n        emit DataTransferred(address(this), address(0), id, data);\n    }\n}", "idx": "152"}, {"project": "Contract153.sol", "commit_id": "0", "target": 0, "func": "pragma solidity ^0.8.0;\n\ncontract CrossChainDataTransferDynamicFormat13 {\n    mapping(bytes32 => string) public storedData;\n    mapping(bytes32 => string) public dataTypes;\n    \n    event DataTransferred(address indexed fromChain, address indexed toChain, bytes32 indexed id, string data);\n\n    function transferData(bytes32 id, string memory data, string memory dataType) public {\n        require(bytes(data).length > 0, \"Data should not be empty\");\n        storedData[id] = data;\n        dataTypes[id] = dataType;\n        emit DataTransferred(address(this), address(0), id, data);\n    }\n}", "idx": "153"}, {"project": "Contract154.sol", "commit_id": "0", "target": 0, "func": "pragma solidity ^0.8.0;\n\ncontract CrossChainDataTransferDynamicFormat14 {\n    mapping(bytes32 => string) public transferredData;\n    mapping(bytes32 => string) public dataTypes;\n    \n    event DataTransferred(address indexed fromChain, address indexed toChain, bytes32 indexed id, string data);\n\n    function transferData(bytes32 id, string memory data, string memory dataType) public {\n        require(bytes(data).length > 0, \"Data should not be empty\");\n        transferredData[id] = data;\n        dataTypes[id] = dataType;\n        emit DataTransferred(address(this), address(0), id, data);\n    }\n}", "idx": "154"}, {"project": "Contract155.sol", "commit_id": "0", "target": 0, "func": "pragma solidity ^0.8.0;\n\ncontract CrossChainDataTransferDynamicFormat15 {\n    mapping(bytes32 => string) public records;\n    mapping(bytes32 => string) public dataTypes;\n    \n    event DataTransferred(address indexed fromChain, address indexed toChain, bytes32 indexed id, string data);\n\n    function transferData(bytes32 id, string memory data, string memory dataType) public {\n        require(bytes(data).length > 0, \"Data should not be empty\");\n        records[id] = data;\n        dataTypes[id] = dataType;\n        emit DataTransferred(address(this), address(0), id, data);\n    }\n}", "idx": "155"}, {"project": "Contract156.sol", "commit_id": "0", "target": 0, "func": "pragma solidity ^0.8.0;\n\ncontract CrossChainDataTransferDynamicFormat16 {\n    mapping(bytes32 => string) public storedData;\n    mapping(bytes32 => string) public dataFormats;\n    \n    event DataTransferred(address indexed fromChain, address indexed toChain, bytes32 indexed id, string data);\n\n    function transferData(bytes32 id, string memory data, string memory dataFormat) public {\n        require(bytes(data).length > 0, \"Data should not be empty\");\n        storedData[id] = data;\n        dataFormats[id] = dataFormat;\n        emit DataTransferred(address(this), address(0), id, data);\n    }\n}", "idx": "156"}, {"project": "Contract157.sol", "commit_id": "0", "target": 0, "func": "pragma solidity ^0.8.0;\n\ncontract CrossChainDataTransferDynamicFormat17 {\n    mapping(bytes32 => string) public transferredData;\n    mapping(bytes32 => string) public dataTypes;\n    \n    event DataTransferred(address indexed fromChain, address indexed toChain, bytes32 indexed id, string data);\n\n    function transferData(bytes32 id, string memory data, string memory dataType) public {\n        require(bytes(data).length > 0, \"Data should not be empty\");\n        transferredData[id] = data;\n        dataTypes[id] = dataType;\n        emit DataTransferred(address(this), address(0), id, data);\n    }\n}", "idx": "157"}, {"project": "Contract158.sol", "commit_id": "0", "target": 0, "func": "pragma solidity ^0.8.0;\n\ncontract CrossChainDataTransferDynamicFormat18 {\n    mapping(bytes32 => string) public storedData;\n    mapping(bytes32 => string) public dataFormats;\n    \n    event DataTransferred(address indexed fromChain, address indexed toChain, bytes32 indexed id, string data);\n\n    function transferData(bytes32 id, string memory data, string memory dataFormat) public {\n        require(bytes(data).length > 0, \"Data should not be empty\");\n        storedData[id] = data;\n        dataFormats[id] = dataFormat;\n        emit DataTransferred(address(this), address(0), id, data);\n    }\n}", "idx": "158"}, {"project": "Contract159.sol", "commit_id": "0", "target": 1, "func": "pragma solidity ^0.8.0;\n\ncontract CrossChainInteraction {\n    address public remoteContractAddress;\n\n    event InteractionInitiated(address initiator, uint256 amount);\n\n    constructor(address _remoteContractAddress) {\n        remoteContractAddress = _remoteContractAddress;\n    }\n\n    function initiateCrossChainInteraction(uint256 amount) public payable {\n        require(remoteContractAddress != address(0), \"Remote contract address not set\");\n        require(amount > 0, \"Invalid amount\");\n\n        (bool success, ) = remoteContractAddress.call{value: amount}(\"\");\n        require(success, \"Cross-chain interaction failed\");\n\n        emit InteractionInitiated(msg.sender, amount);\n    }\n}", "idx": "159"}, {"project": "Contract160.sol", "commit_id": "0", "target": 1, "func": "pragma solidity ^0.8.0;\n\ncontract CrossChainInteraction {\n    address public remoteContractAddress;\n\n    event InteractionInitiated(address initiator, uint256 amount);\n\n    constructor(address _remoteContractAddress) {\n        remoteContractAddress = _remoteContractAddress;\n    }\n\n    function initiateCrossChainInteraction(uint256 amount) public payable {\n        require(remoteContractAddress != address(0), \"Remote contract address not set\");\n        require(amount > 0, \"Invalid amount\");\n\n        (bool success, ) = remoteContractAddress.call{value: amount}(\"\");\n        require(success, \"Cross-chain interaction failed\");\n\n        emit InteractionInitiated(msg.sender, amount);\n    }\n}", "idx": "160"}, {"project": "Contract161.sol", "commit_id": "0", "target": 1, "func": "pragma solidity ^0.8.0;\n\ncontract InterChainCommunicator {\n    address public targetBlockchainContract;\n\n    event InteractionHappened(address sender, uint256 value);\n\n    constructor(address _targetBlockchainContract) {\n        targetBlockchainContract = _targetBlockchainContract;\n    }\n\n    function initiateInterChainInteraction(uint256 amount) public payable {\n        require(targetBlockchainContract != address(0), \"Invalid target contract address\");\n        require(amount > 0, \"Invalid transfer amount\");\n\n        (bool success, ) = targetBlockchainContract.call{value: amount}(\"\");\n        require(success, \"Inter-chain interaction failed\");\n\n        emit InteractionHappened(msg.sender, amount);\n    }\n}", "idx": "161"}, {"project": "Contract162.sol", "commit_id": "0", "target": 1, "func": "pragma solidity ^0.8.0;\n\ncontract InterChainCommunicator {\n    address public targetBlockchainContract;\n\n    event InteractionHappened(address sender, uint256 value);\n\n    constructor(address _targetBlockchainContract) {\n        targetBlockchainContract = _targetBlockchainContract;\n    }\n\n    function initiateInterChainInteraction(uint256 amount) public payable {\n        require(targetBlockchainContract != address(0), \"Invalid target contract address\");\n        require(amount > 0, \"Invalid transfer amount\");\n\n        (bool success, ) = targetBlockchainContract.call{value: amount}(\"\");\n        require(success, \"Inter-chain interaction failed\");\n\n        emit InteractionHappened(msg.sender, amount);\n    }\n}", "idx": "162"}, {"project": "Contract163.sol", "commit_id": "0", "target": 1, "func": "pragma solidity ^0.8.0;\n\ncontract CrossChainGateway {\n    address public remoteEndpoint;\n\n    event CrossChainAction(address initiator, uint256 value);\n\n    constructor(address _remoteEndpoint) {\n        remoteEndpoint = _remoteEndpoint;\n    }\n\n    function initiateCrossChainAction(uint256 amount) public payable {\n        require(remoteEndpoint != address(0), \"Invalid remote endpoint\");\n        require(amount > 0, \"Invalid action amount\");\n\n        (bool success, ) = remoteEndpoint.call{value: amount}(\"\");\n        require(success, \"Cross-chain action failed\");\n\n        emit CrossChainAction(msg.sender, amount);\n    }\n}", "idx": "163"}, {"project": "Contract164.sol", "commit_id": "0", "target": 1, "func": "pragma solidity ^0.8.0;\n\ncontract BlockchainConnector {\n    address public linkedBlockchainContract;\n\n    event CrossBlockchainInteraction(address initiator, uint256 value);\n\n    constructor(address _linkedBlockchainContract) {\n        linkedBlockchainContract = _linkedBlockchainContract;\n    }\n\n    function initiateCrossBlockchainInteraction(uint256 amount) public payable {\n        require(linkedBlockchainContract != address(0), \"Invalid linked contract\");\n        require(amount > 0, \"Invalid transfer amount\");\n\n        (bool success, ) = linkedBlockchainContract.call{value: amount}(\"\");\n        require(success, \"Cross-blockchain interaction failed\");\n\n        emit CrossBlockchainInteraction(msg.sender, amount);\n    }\n}", "idx": "164"}, {"project": "Contract165.sol", "commit_id": "0", "target": 1, "func": "pragma solidity ^0.8.0;\n\ncontract MultiChainMessenger {\n    address public remoteContract;\n\n    event InteractionSent(address sender, uint256 value);\n\n    constructor(address _remoteContract) {\n        remoteContract = _remoteContract;\n    }\n\n    function initiateMultiChainInteraction(uint256 amount) public payable {\n        require(remoteContract != address(0), \"Invalid remote contract address\");\n        require(amount > 0, \"Invalid interaction amount\");\n\n        (bool success, ) = remoteContract.call{value: amount}(\"\");\n        require(success, \"Multi-chain interaction failed\");\n\n        emit InteractionSent(msg.sender, amount);\n    }\n}", "idx": "165"}, {"project": "Contract166.sol", "commit_id": "0", "target": 1, "func": "pragma solidity ^0.8.0;\n\ncontract InterchainCommunicator {\n    address public targetBlockchainContract;\n    mapping(address => uint256) public balances;\n\n    event InteractionInitiated(address sender, uint256 amount, string actionType);\n\n    constructor(address _targetBlockchainContract) {\n        targetBlockchainContract = _targetBlockchainContract;\n    }\n\n    function deposit() public payable {\n        balances[msg.sender] += msg.value;\n    }\n\n    function initiateInterchainInteraction(uint256 amount, string memory actionType) public {\n        require(targetBlockchainContract != address(0), \"Invalid target contract address\");\n        require(amount > 0, \"Invalid interaction amount\");\n\n        (bool success, ) = targetBlockchainContract.call{value: amount}(\"\");\n        require(success, \"Inter-chain interaction failed\");\n\n        emit InteractionInitiated(msg.sender, amount, actionType);\n    }\n}", "idx": "166"}, {"project": "Contract167.sol", "commit_id": "0", "target": 1, "func": "pragma solidity ^0.8.0;\n\ncontract CrossChainConnector {\n    address public remoteEndpoint;\n    mapping(address => uint256) public contributions;\n\n    event InteractionTriggered(address initiator, uint256 value, string action);\n\n    constructor(address _remoteEndpoint) {\n        remoteEndpoint = _remoteEndpoint;\n    }\n\n    function contribute() public payable {\n        contributions[msg.sender] += msg.value;\n    }\n\n    function initiateCrossChainInteraction(uint256 amount, string memory action) public {\n        require(remoteEndpoint != address(0), \"Invalid remote endpoint\");\n        require(amount > 0, \"Invalid interaction amount\");\n\n        (bool success, ) = remoteEndpoint.call{value: amount}(\"\");\n        require(success, \"Cross-chain interaction failed\");\n\n        emit InteractionTriggered(msg.sender, amount, action);\n    }\n}", "idx": "167"}, {"project": "Contract168.sol", "commit_id": "0", "target": 1, "func": "pragma solidity ^0.8.0;\n\ncontract BlockchainInteraction {\n    address public targetChainContract;\n\n    event ActionInitiated(address initiator, uint256 value, string actionType);\n\n    constructor(address _targetChainContract) {\n        targetChainContract = _targetChainContract;\n    }\n\n    function performAction(uint256 amount, string memory actionType) public payable {\n        require(targetChainContract != address(0), \"Invalid target contract address\");\n        require(amount > 0, \"Invalid action amount\");\n\n        (bool success, ) = targetChainContract.call{value: amount}(\"\");\n        require(success, \"Cross-chain action failed\");\n\n        emit ActionInitiated(msg.sender, amount, actionType);\n    }\n}", "idx": "168"}, {"project": "Contract169.sol", "commit_id": "0", "target": 1, "func": "pragma solidity ^0.8.0;\n\ncontract CrossChainAgent {\n    address public remoteContract;\n\n    event InteractionSent(address initiator, uint256 value, string actionType);\n\n    constructor(address _remoteContract) {\n        remoteContract = _remoteContract;\n    }\n\n    function initiateInteraction(uint256 amount, string memory actionType) public payable {\n        require(remoteContract != address(0), \"Invalid remote contract address\");\n        require(amount > 0, \"Invalid interaction amount\");\n\n        (bool success, ) = remoteContract.call{value: amount}(\"\");\n        require(success, \"Interaction failed\");\n\n        emit InteractionSent(msg.sender, amount, actionType);\n    }\n}", "idx": "169"}, {"project": "Contract170.sol", "commit_id": "0", "target": 1, "func": "pragma solidity ^0.8.0;\n\ncontract CrossBlockchainGateway {\n    address public targetBlockchainContract;\n\n    event CrossBlockchainInteraction(address initiator, uint256 value, string actionType);\n\n    constructor(address _targetBlockchainContract) {\n        targetBlockchainContract = _targetBlockchainContract;\n    }\n\n    function initiateCrossBlockchainAction(uint256 amount, string memory actionType) public payable {\n        require(targetBlockchainContract != address(0), \"Invalid target contract\");\n        require(amount > 0, \"Invalid action amount\");\n\n        (bool success, ) = targetBlockchainContract.call{value: amount}(\"\");\n        require(success, \"Cross-blockchain action failed\");\n\n        emit CrossBlockchainInteraction(msg.sender, amount, actionType);\n    }\n}", "idx": "170"}, {"project": "Contract171.sol", "commit_id": "0", "target": 1, "func": "pragma solidity ^0.8.0;\n\ncontract VulnerableExternalContract {\n    mapping(address => uint) public balances;\n\n    function deposit() public payable {\n        balances[msg.sender] += msg.value;\n    }\n\n    function withdraw(uint amount) public {\n        require(amount <= balances[msg.sender], \"Insufficient balance\");\n        (bool success, ) = msg.sender.call{value: amount}(\"\");\n        require(success, \"Transfer failed\");\n        balances[msg.sender] -= amount;\n    }\n}", "idx": "171"}, {"project": "Contract172.sol", "commit_id": "0", "target": 1, "func": "pragma solidity ^0.8.0;\n\ncontract VulnerableExternalContract2 {\n    mapping(address => uint) public balances;\n\n    function deposit() public payable {\n        balances[msg.sender] += msg.value;\n    }\n\n    function withdraw(uint amount) public {\n        require(amount <= balances[msg.sender], \"Insufficient balance\");\n\n        uint userBalance = balances[msg.sender];\n        (bool success, ) = msg.sender.call{value: userBalance}(\"\");\n        require(success, \"Transfer failed\");\n\n        balances[msg.sender] -= amount;\n    }\n}", "idx": "172"}, {"project": "Contract173.sol", "commit_id": "0", "target": 1, "func": "pragma solidity ^0.8.0;\n\ncontract VulnerableExternalContract3 {\n    mapping(address => uint) public balances;\n\n    function deposit() public payable {\n        balances[msg.sender] += msg.value;\n    }\n\n    function withdraw(uint amount) public {\n        require(amount <= balances[msg.sender], \"Insufficient balance\");\n\n        balances[msg.sender] -= amount;\n\n        (bool success, ) = msg.sender.call{value: amount}(\"\");\n        require(success, \"Transfer failed\");\n    }\n}", "idx": "173"}, {"project": "Contract174.sol", "commit_id": "0", "target": 1, "func": "pragma solidity ^0.8.0;\n\ncontract VulnerableExternalContract4 {\n    mapping(address => uint) public balances;\n\n    function deposit() public payable {\n        balances[msg.sender] += msg.value;\n    }\n\n    function withdraw(uint amount) public {\n        uint balance = balances[msg.sender];\n        require(balance >= amount, \"Insufficient balance\");\n\n        balances[msg.sender] = balance - amount;\n        (bool success, ) = msg.sender.call{value: amount}(\"\");\n        require(success, \"Transfer failed\");\n    }\n}", "idx": "174"}, {"project": "Contract175.sol", "commit_id": "0", "target": 1, "func": "pragma solidity ^0.8.0;\n\ncontract VulnerableExternalContract5 {\n    mapping(address => uint) public balances;\n\n    function deposit() public payable {\n        balances[msg.sender] += msg.value;\n    }\n\n    function withdraw(uint amount) public {\n        require(amount <= balances[msg.sender], \"Insufficient balance\");\n\n        while (amount > 0) {\n            (bool success, ) = msg.sender.call{value: 1 ether}(\"\");\n            require(success, \"Transfer failed\");\n            amount--;\n        }\n\n        balances[msg.sender] -= amount;\n    }\n}", "idx": "175"}, {"project": "Contract176.sol", "commit_id": "0", "target": 1, "func": "pragma solidity ^0.8.0;\n\ncontract VulnerableExternalContract6 {\n    mapping(address => uint) public balances;\n\n    function deposit() public payable {\n        balances[msg.sender] += msg.value;\n    }\n\n    function withdraw(uint amount) public {\n        if (amount > 0) {\n            (bool success, ) = msg.sender.call{value: 1 ether}(\"\");\n            require(success, \"Transfer failed\");\n            withdraw(amount - 1);\n        }\n\n        balances[msg.sender] -= amount;\n    }\n}", "idx": "176"}, {"project": "Contract177.sol", "commit_id": "0", "target": 1, "func": "pragma solidity ^0.8.0;\n\ncontract VulnerableExternalContract7 {\n    mapping(address => uint) public balances;\n\n    function deposit() public payable {\n        balances[msg.sender] += msg.value;\n    }\n\n    function withdraw(uint amount) public {\n        require(amount <= balances[msg.sender], \"Insufficient balance\");\n\n        uint userBalance = balances[msg.sender];\n        balances[msg.sender] = 0;\n\n        (bool success, ) = msg.sender.call{value: userBalance}(\"\");\n        require(success, \"Transfer failed\");\n    }\n}", "idx": "177"}, {"project": "Contract178.sol", "commit_id": "0", "target": 1, "func": "pragma solidity ^0.8.0;\n\ncontract VulnerableExternalContract8 {\n    mapping(address => uint) public balances;\n\n    function deposit() public payable {\n        balances[msg.sender] += msg.value;\n    }\n\n    function withdraw(uint amount) public {\n        require(amount <= balances[msg.sender], \"Insufficient balance\");\n\n        (bool success, ) = msg.sender.call{value: amount}(\"\");\n        require(success, \"Transfer failed\");\n\n        balances[msg.sender] -= amount;\n    }\n}", "idx": "178"}, {"project": "Contract179.sol", "commit_id": "0", "target": 1, "func": "pragma solidity ^0.8.0;\n\ncontract VulnerableExternalContract9 {\n    mapping(address => uint) public balances;\n\n    function deposit() public payable {\n        balances[msg.sender] += msg.value;\n    }\n\n    function withdraw(uint amount) public {\n        uint balance = balances[msg.sender];\n\n        (bool success, ) = msg.sender.call{value: balance}(\"\");\n        require(success, \"Transfer failed\");\n\n        balances[msg.sender] -= amount;\n    }\n}", "idx": "179"}, {"project": "Contract180.sol", "commit_id": "0", "target": 1, "func": "pragma solidity ^0.8.0;\n\ncontract VulnerableExternalContract10 {\n    mapping(address => uint) public balances;\n\n    function deposit() public payable {\n        balances[msg.sender] += msg.value;\n    }\n\n    function withdraw(uint amount) public {\n        uint balance = balances[msg.sender];\n\n        (bool success, ) = msg.sender.call{value: amount}(\"\");\n        require(success, \"Transfer failed\");\n\n        balances[msg.sender] = balance - amount;\n    }\n}", "idx": "180"}, {"project": "Contract181.sol", "commit_id": "0", "target": 1, "func": "pragma solidity ^0.8.0;\n\ncontract ReentrancyExploit {\n    address public target;\n    \n    constructor(address _target) {\n        target = _target;\n    }\n    \n    function attack() public payable {\n        (bool success, ) = target.call{value: msg.value}(\"\");\n        require(success, \"Call failed\");\n    }\n    \n    function getBalance() public view returns (uint) {\n        return address(this).balance;\n    }\n\n    function vulnerableWithdraw(uint amount) public {\n        require(amount <= address(this).balance, \"Insufficient balance\");\n        (bool success, ) = msg.sender.call{value: amount}(\"\");\n        require(success, \"Transfer failed\");\n    }\n    \n    fallback() external payable {}\n}", "idx": "181"}, {"project": "Contract182.sol", "commit_id": "0", "target": 1, "func": "pragma solidity ^0.8.0;\n\ncontract ReentrancyExploit2 {\n    address public target;\n    \n    constructor(address _target) {\n        target = _target;\n    }\n    \n    function attack() public payable {\n        if (msg.value >= 1 ether) {\n            (bool success, ) = target.call{value: 1 ether}(\"\");\n            require(success, \"Call failed\");\n            attack();\n        }\n    }\n    \n    function getBalance() public view returns (uint) {\n        return address(this).balance;\n    }\n\n    function vulnerableWithdraw(uint amount) public {\n        require(amount <= address(this).balance, \"Insufficient balance\");\n        (bool success, ) = msg.sender.call{value: amount}(\"\");\n        require(success, \"Transfer failed\");\n    }\n    \n    fallback() external payable {}\n}", "idx": "182"}, {"project": "Contract183.sol", "commit_id": "0", "target": 1, "func": "pragma solidity ^0.8.0;\n\ncontract ReentrancyExploit3 {\n    address public target;\n    \n    constructor(address _target) {\n        target = _target;\n    }\n    \n    function attack() public payable {\n        // Exploit: Repeated reentrancy attack\n        for (uint i = 0; i < 10; i++) {\n            (bool success, ) = target.call{value: 0.1 ether}(\"\");\n            require(success, \"Call failed\");\n        }\n    }\n    \n    function getBalance() public view returns (uint) {\n        return address(this).balance;\n    }\n\n    function vulnerableWithdraw(uint amount) public {\n        require(amount <= address(this).balance, \"Insufficient balance\");\n        (bool success, ) = msg.sender.call{value: amount}(\"\");\n        require(success, \"Transfer failed\");\n    }\n    \n    fallback() external payable {}\n}", "idx": "183"}, {"project": "Contract184.sol", "commit_id": "0", "target": 1, "func": "pragma solidity ^0.8.0;\n\ncontract ReentrancyExploit4 {\n    address public target;\n    \n    constructor(address _target) {\n        target = _target;\n    }\n    \n    function attack() public payable {\n        // Exploit: Immediate reentrancy attack\n        (bool success, ) = target.call{value: msg.value}(\"\");\n        require(success, \"Call failed\");\n        (bool success2, ) = target.call{value: msg.value}(\"\");\n        require(success2, \"Second call failed\");\n    }\n    \n    function getBalance() public view returns (uint) {\n        return address(this).balance;\n    }\n\n    function vulnerableWithdraw(uint amount) public {\n        require(amount <= address(this).balance, \"Insufficient balance\");\n        (bool success, ) = msg.sender.call{value: amount}(\"\");\n        require(success, \"Transfer failed\");\n    }\n    \n    fallback() external payable {}\n}", "idx": "184"}, {"project": "Contract185.sol", "commit_id": "0", "target": 1, "func": "pragma solidity ^0.8.0;\n\ncontract ReentrancyExploit5 {\n    address public target;\n    \n    constructor(address _target) {\n        target = _target;\n    }\n    \n    function attack() public payable {\n        // Exploit: Reentrancy attack with varying amounts\n        uint amountToSend = 0.1 ether;\n        while (amountToSend < msg.value) {\n            (bool success, ) = target.call{value: amountToSend}(\"\");\n            require(success, \"Call failed\");\n            amountToSend += 0.1 ether;\n        }\n    }\n    \n    function getBalance() public view returns (uint) {\n        return address(this).balance;\n    }\n\n    function vulnerableWithdraw(uint amount) public {\n        require(amount <= address(this).balance, \"Insufficient balance\");\n        (bool success, ) = msg.sender.call{value: amount}(\"\");\n        require(success, \"Transfer failed\");\n    }\n    \n    fallback() external payable {}\n}", "idx": "185"}, {"project": "Contract186.sol", "commit_id": "0", "target": 1, "func": "pragma solidity ^0.8.0;\n\ncontract ReentrancyExploit6 {\n    address public target;\n    \n    constructor(address _target) {\n        target = _target;\n    }\n    \n    function attack() public payable {\n        // Exploit: Recursive reentrancy attack with decreasing value\n        uint value = msg.value;\n        while (value >= 1 ether) {\n            (bool success, ) = target.call{value: 1 ether}(\"\");\n            require(success, \"Call failed\");\n            value -= 1 ether;\n        }\n    }\n    \n    function getBalance() public view returns (uint) {\n        return address(this).balance;\n    }\n\n    function vulnerableWithdraw(uint amount) public {\n        require(amount <= address(this).balance, \"Insufficient balance\");\n        (bool success, ) = msg.sender.call{value: amount}(\"\");\n        require(success, \"Transfer failed\");\n    }\n    \n    fallback() external payable {}\n}", "idx": "186"}, {"project": "Contract187.sol", "commit_id": "0", "target": 1, "func": "pragma solidity ^0.8.0;\n\ncontract ReentrancyExploit7 {\n    address public target;\n    \n    constructor(address _target) {\n        target = _target;\n    }\n    \n    function attack() public payable {\n        uint value = 0.1 ether;\n        while (value <= msg.value) {\n            (bool success, ) = target.call{value: value}(\"\");\n            require(success, \"Call failed\");\n            value += 0.1 ether;\n        }\n    }\n    \n    function getBalance() public view returns (uint) {\n        return address(this).balance;\n    }\n\n    function vulnerableWithdraw(uint amount) public {\n        require(amount <= address(this).balance, \"Insufficient balance\");\n        (bool success, ) = msg.sender.call{value: amount}(\"\");\n        require(success, \"Transfer failed\");\n    }\n    \n    fallback() external payable {}\n}", "idx": "187"}, {"project": "Contract188.sol", "commit_id": "0", "target": 1, "func": "pragma solidity ^0.8.0;\n\ncontract ReentrancyExploit8 {\n    address public target;\n    \n    constructor(address _target) {\n        target = _target;\n    }\n    \n    function attack() public payable {\n        // Exploit: Repeated reentrancy attack with decreasing value\n        uint value = msg.value;\n        for (uint i = 0; i < 10; i++) {\n            (bool success, ) = target.call{value: value}(\"\");\n            require(success, \"Call failed\");\n            value -= 0.1 ether;\n        }\n    }\n    \n    function getBalance() public view returns (uint) {\n        return address(this).balance;\n    }\n\n    function vulnerableWithdraw(uint amount) public {\n        require(amount <= address(this).balance, \"Insufficient balance\");\n        (bool success, ) = msg.sender.call{value: amount}(\"\");\n        require(success, \"Transfer failed\");\n    }\n    \n    fallback() external payable {}\n}", "idx": "188"}, {"project": "Contract189.sol", "commit_id": "0", "target": 1, "func": "pragma solidity ^0.8.0;\n\ncontract ReentrancyExploit9 {\n    address public target;\n    \n    constructor(address _target) {\n        target = _target;\n    }\n    \n    function attack() public payable {\n        // Exploit: Reentrancy attack with varying amounts and increasing calls\n        uint amount = 0.1 ether;\n        for (uint i = 0; i < 10; i++) {\n            (bool success, ) = target.call{value: amount}(\"\");\n            require(success, \"Call failed\");\n            amount += 0.1 ether;\n        }\n    }\n    \n    function getBalance() public view returns (uint) {\n        return address(this).balance;\n    }\n\n    function vulnerableWithdraw(uint amount) public {\n        require(amount <= address(this).balance, \"Insufficient balance\");\n        (bool success, ) = msg.sender.call{value: amount}(\"\");\n        require(success, \"Transfer failed\");\n    }\n    \n    fallback() external payable {}\n}", "idx": "189"}, {"project": "Contract190.sol", "commit_id": "0", "target": 1, "func": "pragma solidity ^0.8.0;\n\ncontract ReentrancyExploit10 {\n    address public target;\n    \n    constructor(address _target) {\n        target = _target;\n    }\n    \n    function attack() public payable {\n        // Exploit: Recursive reentrancy attack with fixed value\n        recursiveCall(10);\n    }\n    \n    function recursiveCall(uint256 n) internal {\n        if (n == 0) return;\n        (bool success, ) = target.call{value: 0.1 ether}(\"\");\n        require(success, \"Call failed\");\n        recursiveCall(n - 1);\n    }\n\n    function getBalance() public view returns (uint) {\n        return address(this).balance;\n    }\n\n    function vulnerableWithdraw(uint amount) public {\n        require(amount <= address(this).balance, \"Insufficient balance\");\n        (bool success, ) = msg.sender.call{value: amount}(\"\");\n        require(success, \"Transfer failed\");\n    }\n    \n    fallback() external payable {}\n}", "idx": "190"}, {"project": "Contract191.sol", "commit_id": "0", "target": 1, "func": "pragma solidity ^0.8.0;\n\ncontract UnintendedBehaviorDemo {\n    uint256 public balance;\n\n    function deposit() public payable {\n        balance += msg.value;\n    }\n\n    function maliciousCall(uint256 amount) public {\n        require(balance >= amount, \"Insufficient balance\");\n\n        if (amount >= 1 ether) {\n            maliciousCall(amount - 1 ether);\n        }\n\n        balance -= amount;\n        (bool success, ) = msg.sender.call{value: amount}(\"\");\n        require(success, \"Transfer failed\");\n    }\n\n    function getBalance() public view returns (uint256) {\n        return balance;\n    }\n\n    fallback() external payable {\n        maliciousCall(10 ether);\n    }\n}", "idx": "191"}, {"project": "Contract192.sol", "commit_id": "0", "target": 1, "func": "pragma solidity ^0.8.0;\n\ncontract UnintendedBehaviorDemo2 {\n    uint256 public balance;\n\n    function deposit() public payable {\n        balance += msg.value;\n    }\n\n    function maliciousCall(uint256 amount) public {\n        require(balance >= amount, \"Insufficient balance\");\n\n        if (amount >= 1 ether) {\n            maliciousCall(amount / 2);\n            maliciousCall(amount / 2);\n        }\n\n        balance -= amount;\n        (bool success, ) = msg.sender.call{value: amount}(\"\");\n        require(success, \"Transfer failed\");\n    }\n\n    function getBalance() public view returns (uint256) {\n        return balance;\n    }\n\n    fallback() external payable {\n        maliciousCall(10 ether);\n    }\n}", "idx": "192"}, {"project": "Contract193.sol", "commit_id": "0", "target": 1, "func": "pragma solidity ^0.8.0;\n\ncontract UnintendedBehaviorDemo3 {\n    uint256 public balance;\n\n    function deposit() public payable {\n        balance += msg.value;\n    }\n\n    function maliciousCall(uint256 amount) public {\n        require(balance >= amount, \"Insufficient balance\");\n\n        while (amount >= 1 ether) {\n            maliciousCall(amount / 2);\n            amount /= 2;\n        }\n\n        balance -= amount;\n        (bool success, ) = msg.sender.call{value: amount}(\"\");\n        require(success, \"Transfer failed\");\n    }\n\n    function getBalance() public view returns (uint256) {\n        return balance;\n    }\n\n    fallback() external payable {\n        maliciousCall(10 ether);\n    }\n}", "idx": "193"}, {"project": "Contract194.sol", "commit_id": "0", "target": 1, "func": "pragma solidity ^0.8.0;\n\ncontract UnintendedBehaviorDemo4 {\n    uint256 public balance;\n\n    function deposit() public payable {\n        balance += msg.value;\n    }\n\n    function maliciousCall(uint256 amount) public {\n        require(balance >= amount, \"Insufficient balance\");\n\n        if (amount % 2 == 0) {\n            maliciousCall(amount / 2);\n        } else {\n            maliciousCall(amount / 3);\n        }\n\n        balance -= amount;\n        (bool success, ) = msg.sender.call{value: amount}(\"\");\n        require(success, \"Transfer failed\");\n    }\n\n    function getBalance() public view returns (uint256) {\n        return balance;\n    }\n\n    fallback() external payable {\n        maliciousCall(10 ether);\n    }\n}", "idx": "194"}, {"project": "Contract195.sol", "commit_id": "0", "target": 1, "func": "pragma solidity ^0.8.0;\n\ncontract UnintendedBehaviorDemo5 {\n    uint256 public balance;\n\n    function deposit() public payable {\n        balance += msg.value;\n    }\n\n    function maliciousCall(uint256 amount) public {\n        require(balance >= amount, \"Insufficient balance\");\n\n        if (amount > 1 ether) {\n            maliciousCall(amount - 1 ether);\n        }\n\n        balance -= amount;\n        (bool success, ) = msg.sender.call{value: amount}(\"\");\n        require(success, \"Transfer failed\");\n    }\n\n    function getBalance() public view returns (uint256) {\n        return balance;\n    }\n\n    fallback() external payable {\n        maliciousCall(10 ether);\n    }\n}", "idx": "195"}, {"project": "Contract196.sol", "commit_id": "0", "target": 1, "func": "pragma solidity ^0.8.0;\n\ncontract UnintendedBehaviorDemo6 {\n    uint256 public balance;\n\n    function deposit() public payable {\n        balance += msg.value;\n    }\n\n    function maliciousCall(uint256 amount) public {\n        require(balance >= amount, \"Insufficient balance\");\n\n        if (amount >= 1 ether) {\n            maliciousCall(amount + 1 ether);\n        }\n\n        balance -= amount;\n        (bool success, ) = msg.sender.call{value: amount}(\"\");\n        require(success, \"Transfer failed\");\n    }\n\n    function getBalance() public view returns (uint256) {\n        return balance;\n    }\n\n    fallback() external payable {\n        maliciousCall(10 ether);\n    }\n}", "idx": "196"}, {"project": "Contract197.sol", "commit_id": "0", "target": 1, "func": "pragma solidity ^0.8.0;\n\ncontract UnintendedBehaviorDemo7 {\n    uint256 public balance;\n\n    function deposit() public payable {\n        balance += msg.value;\n    }\n\n    function maliciousCall(uint256 amount) public {\n        require(balance >= amount, \"Insufficient balance\");\n\n        if (amount >= 1 ether) {\n            maliciousCall(amount - 0.9 ether);\n        }\n\n        balance -= amount;\n        (bool success, ) = msg.sender.call{value: amount}(\"\");\n        require(success, \"Transfer failed\");\n    }\n\n    function getBalance() public view returns (uint256) {\n        return balance;\n    }\n\n    fallback() external payable {\n        maliciousCall(10 ether);\n    }\n}", "idx": "197"}, {"project": "Contract198.sol", "commit_id": "0", "target": 1, "func": "pragma solidity ^0.8.0;\n\ncontract UnintendedBehaviorDemo8 {\n    uint256 public balance;\n\n    function deposit() public payable {\n        balance += msg.value;\n    }\n\n    function maliciousCall(uint256 amount) public {\n        require(balance >= amount, \"Insufficient balance\");\n\n        if (amount >= 1 ether) {\n            maliciousCall(amount / 4);\n        }\n\n        balance -= amount;\n        (bool success, ) = msg.sender.call{value: amount}(\"\");\n        require(success, \"Transfer failed\");\n    }\n\n    function getBalance() public view returns (uint256) {\n        return balance;\n    }\n\n    fallback() external payable {\n        maliciousCall(10 ether);\n    }\n}", "idx": "198"}, {"project": "Contract199.sol", "commit_id": "0", "target": 1, "func": "pragma solidity ^0.8.0;\n\ncontract UnintendedBehaviorDemo9 {\n    uint256 public balance;\n\n    function deposit() public payable {\n        balance += msg.value;\n    }\n\n    function maliciousCall(uint256 amount) public {\n        require(balance >= amount, \"Insufficient balance\");\n\n        if (amount >= 1 ether) {\n            maliciousCall(amount - 0.1 ether);\n            maliciousCall(amount - 0.1 ether);\n        }\n\n        balance -= amount;\n        (bool success, ) = msg.sender.call{value: amount}(\"\");\n        require(success, \"Transfer failed\");\n    }\n\n    function getBalance() public view returns (uint256) {\n        return balance;\n    }\n\n    fallback() external payable {\n        maliciousCall(10 ether);\n    }\n}", "idx": "199"}, {"project": "Contract200.sol", "commit_id": "0", "target": 1, "func": "pragma solidity ^0.8.0;\n\ncontract UnintendedBehaviorDemo10 {\n    uint256 public balance;\n\n    function deposit() public payable {\n        balance += msg.value;\n    }\n\n    function maliciousCall(uint256 amount) public {\n        require(balance >= amount, \"Insufficient balance\");\n\n        if (amount >= 1 ether) {\n            maliciousCall(amount / 2);\n        }\n\n        balance -= amount;\n        (bool success, ) = msg.sender.call{value: amount}(\"\");\n        require(success, \"Transfer failed\");\n    }\n\n    function getBalance() public view returns (uint256) {\n        return balance;\n    }\n\n    fallback() external payable {\n        maliciousCall(10 ether);\n    }\n}", "idx": "200"}, {"project": "Contract201.sol", "commit_id": "0", "target": 1, "func": "pragma solidity ^0.8.0;\n\ncontract IntegerOverflowUnderflowExample {\n    uint256 public maxValue = 2**256 - 1;\n\n    function triggerOverflow() public view returns (uint256) {\n        uint256 result = maxValue + 1;\n        return result;\n    }\n\n    function triggerUnderflow() public view returns (uint256) {\n        uint256 result = 0 - 1;\n        return result;\n    }\n}", "idx": "201"}, {"project": "Contract202.sol", "commit_id": "0", "target": 1, "func": "pragma solidity ^0.8.0;\n\ncontract OverflowUnderflowExample1 {\n    uint256 public maxVal = 2**256 - 1;\n\n    function causeOverflow() public view returns (uint256) {\n        uint256 result = maxVal + 1;\n        return result;\n    }\n\n    function causeUnderflow() public view returns (uint256) {\n        uint256 result = 0 - 1;\n        return result;\n    }\n}", "idx": "202"}, {"project": "Contract203.sol", "commit_id": "0", "target": 1, "func": "pragma solidity ^0.8.0;\n\ncontract IntegerIssuesExample2 {\n    uint256 public topValue = 2**256 - 1;\n\n    function createOverflow() public view returns (uint256) {\n        uint256 result = topValue + 1;\n        return result;\n    }\n\n    function createUnderflow() public view returns (uint256) {\n        uint256 result = 0 - 1;\n        return result;\n    }\n}", "idx": "203"}, {"project": "Contract204.sol", "commit_id": "0", "target": 1, "func": "pragma solidity ^0.8.0;\n\ncontract OverflowUnderflowDemo3 {\n    uint256 public maximumValue = 2**256 - 1;\n\n    function causeOverflow() public view returns (uint256) {\n        uint256 result = maximumValue + 1;\n        return result;\n    }\n\n    function causeUnderflow() public view returns (uint256) {\n        uint256 result = 0 - 1;\n        return result;\n    }\n}", "idx": "204"}, {"project": "Contract205.sol", "commit_id": "0", "target": 1, "func": "pragma solidity ^0.8.0;\n\ncontract IntegerIssuesExample4 {\n    uint256 public topVal = 2**256 - 1;\n\n    function causeOverflow() public view returns (uint256) {\n        uint256 result = topVal + 1;\n        return result;\n    }\n\n    function causeUnderflow() public view returns (uint256) {\n        uint256 result = 0 - 1;\n        return result;\n    }\n}", "idx": "205"}, {"project": "Contract206.sol", "commit_id": "0", "target": 1, "func": "pragma solidity ^0.8.0;\n\ncontract DemoIntegerOverflowUnderflow5 {\n    uint256 public maxValue = 2**256 - 1;\n\n    function causeOverflow() public view returns (uint256) {\n        uint256 result = maxValue + 1;\n        return result;\n    }\n\n    function causeUnderflow() public view returns (uint256) {\n        uint256 result = 0 - 1;\n        return result;\n    }\n}", "idx": "206"}, {"project": "Contract207.sol", "commit_id": "0", "target": 1, "func": "pragma solidity ^0.8.0;\n\ncontract DataValidationExample {\n    uint256 public counter;\n\n    function increment(uint256 value) public {\n        require(value > 0, \"Value must be greater than zero\");\n        require(value + counter > counter, \"Integer overflow detected\");\n        \n        counter += value;\n    }\n\n    function decrement(uint256 value) public {\n        require(value > 0, \"Value must be greater than zero\");\n        require(value <= counter, \"Value exceeds the current counter\");\n\n        counter -= value;\n    }\n}", "idx": "207"}, {"project": "Contract208.sol", "commit_id": "0", "target": 1, "func": "pragma solidity ^0.8.0;\n\ncontract DataValidationExample1 {\n    uint256 public counter;\n\n    function increaseCounter(uint256 value) public {\n        require(value > 0, \"Value must be greater than zero\");\n        require(value + counter > counter, \"Integer overflow detected\");\n        \n        counter += value;\n    }\n\n    function decreaseCounter(uint256 value) public {\n        require(value > 0, \"Value must be greater than zero\");\n        require(value <= counter, \"Value exceeds the current counter\");\n\n        counter -= value;\n    }\n}", "idx": "208"}, {"project": "Contract209.sol", "commit_id": "0", "target": 1, "func": "pragma solidity ^0.8.0;\n\ncontract DataValidationExample2 {\n    uint256 public total;\n\n    function addValue(uint256 value) public {\n        require(value > 0, \"Value must be greater than zero\");\n        require(value + total > total, \"Integer overflow detected\");\n        \n        total += value;\n    }\n\n    function subtractValue(uint256 value) public {\n        require(value > 0, \"Value must be greater than zero\");\n        require(value <= total, \"Value exceeds the current total\");\n\n        total -= value;\n    }\n}", "idx": "209"}, {"project": "Contract210.sol", "commit_id": "0", "target": 1, "func": "pragma solidity ^0.8.0;\n\ncontract DataValidationDemo3 {\n    uint256 public currentValue;\n\n    function incrementValue(uint256 value) public {\n        require(value > 0, \"Value must be greater than zero\");\n        require(value + currentValue > currentValue, \"Integer overflow detected\");\n        \n        currentValue += value;\n    }\n\n    function decrementValue(uint256 value) public {\n        require(value > 0, \"Value must be greater than zero\");\n        require(value <= currentValue, \"Value exceeds the current value\");\n\n        currentValue -= value;\n    }\n}", "idx": "210"}, {"project": "Contract211.sol", "commit_id": "0", "target": 1, "func": "pragma solidity ^0.8.0;\n\ncontract DataValidationExample4 {\n    uint256 public dataValue;\n\n    function increaseData(uint256 value) public {\n        require(value > 0, \"Value must be greater than zero\");\n        require(value + dataValue > dataValue, \"Integer overflow detected\");\n        \n        dataValue += value;\n    }\n\n    function decreaseData(uint256 value) public {\n        require(value > 0, \"Value must be greater than zero\");\n        require(value <= dataValue, \"Value exceeds the current data value\");\n\n        dataValue -= value;\n    }\n}", "idx": "211"}, {"project": "Contract212.sol", "commit_id": "0", "target": 1, "func": "pragma solidity ^0.8.0;\n\ncontract ValidationExample5 {\n    uint256 public totalValue;\n\n    function addAmount(uint256 amount) public {\n        require(amount > 0, \"Amount must be greater than zero\");\n        require(amount + totalValue > totalValue, \"Integer overflow detected\");\n        \n        totalValue += amount;\n    }\n\n    function subtractAmount(uint256 amount) public {\n        require(amount > 0, \"Amount must be greater than zero\");\n        require(amount <= totalValue, \"Amount exceeds the current total value\");\n\n        totalValue -= amount;\n    }\n}", "idx": "212"}, {"project": "Contract213.sol", "commit_id": "0", "target": 1, "func": "pragma solidity ^0.8.0;\n\ncontract DataTypesExample {\n    uint8 public smallNumber;\n    uint256 public largeNumber;\n\n    function setSmallNumber(uint8 _value) public {\n        smallNumber = _value;\n    }\n\n    function setLargeNumber(uint256 _value) public {\n        largeNumber = _value;\n    }\n}", "idx": "213"}, {"project": "Contract214.sol", "commit_id": "0", "target": 1, "func": "pragma solidity ^0.8.0;\n\ncontract DataTypesExample1 {\n    uint8 public tinyValue;\n    uint256 public bigValue;\n\n    function setTinyValue(uint8 _value) public {\n        tinyValue = _value;\n    }\n\n    function setBigValue(uint256 _value) public {\n        bigValue = _value;\n    }\n}", "idx": "214"}, {"project": "Contract215.sol", "commit_id": "0", "target": 1, "func": "pragma solidity ^0.8.0;\n\ncontract DataRepresentationDemo2 {\n    uint8 public lowNumber;\n    uint256 public highNumber;\n\n    function setLowNumber(uint8 _value) public {\n        lowNumber = _value;\n    }\n\n    function setHighNumber(uint256 _value) public {\n        highNumber = _value;\n    }\n}", "idx": "215"}, {"project": "Contract216.sol", "commit_id": "0", "target": 1, "func": "pragma solidity ^0.8.0;\n\ncontract DataTypesExample3 {\n    uint8 public tinyVal;\n    uint256 public hugeVal;\n\n    function setTinyVal(uint8 _value) public {\n        tinyVal = _value;\n    }\n\n    function setHugeVal(uint256 _value) public {\n        hugeVal = _value;\n    }\n}", "idx": "216"}, {"project": "Contract217.sol", "commit_id": "0", "target": 1, "func": "pragma solidity ^0.8.0;\n\ncontract DataRepresentationDemo4 {\n    uint8 public smallVal;\n    uint256 public largeVal;\n\n    function setSmallVal(uint8 _value) public {\n        smallVal = _value;\n    }\n\n    function setLargeVal(uint256 _value) public {\n        largeVal = _value;\n    }\n}", "idx": "217"}, {"project": "Contract218.sol", "commit_id": "0", "target": 1, "func": "pragma solidity ^0.8.0;\n\ncontract TypesAndRepresentationsDemo5 {\n    uint8 public shortValue;\n    uint256 public longValue;\n\n    function setShortValue(uint8 _value) public {\n        shortValue = _value;\n    }\n\n    function setLongValue(uint256 _value) public {\n        longValue = _value;\n    }\n}", "idx": "218"}, {"project": "Contract219.sol", "commit_id": "0", "target": 1, "func": "pragma solidity ^0.8.0;\n\ncontract SecureCodingExample {\n    address private owner;\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Not the contract owner\");\n        _;\n    }\n\n    function changeOwner(address _newOwner) public onlyOwner {\n        require(_newOwner != address(0), \"Invalid new owner address\");\n        owner = _newOwner;\n    }\n\n    function withdraw(uint256 _amount) public onlyOwner {\n        require(_amount > 0, \"Amount must be greater than zero\");\n        require(address(this).balance >= _amount, \"Insufficient contract balance\");\n        \n        payable(msg.sender).transfer(_amount);\n    }\n}", "idx": "219"}, {"project": "Contract220.sol", "commit_id": "0", "target": 1, "func": "pragma solidity ^0.8.0;\n\ncontract SecureCodingExample1 {\n    address private contractOwner;\n\n    constructor() {\n        contractOwner = msg.sender;\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == contractOwner, \"Not the contract owner\");\n        _;\n    }\n\n    function changeOwner(address _newOwner) public onlyOwner {\n        require(_newOwner != address(0), \"Invalid new owner address\");\n        contractOwner = _newOwner;\n    }\n\n    function withdrawFunds(uint256 _amount) public onlyOwner {\n        require(_amount > 0, \"Amount must be greater than zero\");\n        require(address(this).balance >= _amount, \"Insufficient contract balance\");\n        \n        payable(msg.sender).transfer(_amount);\n    }\n}", "idx": "220"}, {"project": "Contract221.sol", "commit_id": "0", "target": 1, "func": "pragma solidity ^0.8.0;\n\ncontract SecureCodingExample2 {\n    address private ownerOfContract;\n\n    constructor() {\n        ownerOfContract = msg.sender;\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == ownerOfContract, \"Not the contract owner\");\n        _;\n    }\n\n    function changeContractOwner(address _newOwner) public onlyOwner {\n        require(_newOwner != address(0), \"Invalid new owner address\");\n        ownerOfContract = _newOwner;\n    }\n\n    function withdrawEther(uint256 _amount) public onlyOwner {\n        require(_amount > 0, \"Amount must be greater than zero\");\n        require(address(this).balance >= _amount, \"Insufficient contract balance\");\n        \n        payable(msg.sender).transfer(_amount);\n    }\n}", "idx": "221"}, {"project": "Contract222.sol", "commit_id": "0", "target": 1, "func": "pragma solidity ^0.8.0;\n\ncontract SecureCodeDemo3 {\n    address private contractController;\n\n    constructor() {\n        contractController = msg.sender;\n    }\n\n    modifier onlyController() {\n        require(msg.sender == contractController, \"Not the contract controller\");\n        _;\n    }\n\n    function changeController(address _newController) public onlyController {\n        require(_newController != address(0), \"Invalid new controller address\");\n        contractController = _newController;\n    }\n\n    function withdrawFunds(uint256 _amount) public onlyController {\n        require(_amount > 0, \"Amount must be greater than zero\");\n        require(address(this).balance >= _amount, \"Insufficient contract balance\");\n        \n        payable(msg.sender).transfer(_amount);\n    }\n}", "idx": "222"}, {"project": "Contract223.sol", "commit_id": "0", "target": 1, "func": "pragma solidity ^0.8.0;\n\ncontract SecureCodingDemo4 {\n    address private contractAdmin;\n\n    constructor() {\n        contractAdmin = msg.sender;\n    }\n\n    modifier onlyAdmin() {\n        require(msg.sender == contractAdmin, \"Not the contract admin\");\n        _;\n    }\n\n    function changeAdmin(address _newAdmin) public onlyAdmin {\n        require(_newAdmin != address(0), \"Invalid new admin address\");\n        contractAdmin = _newAdmin;\n    }\n\n    function withdrawFunds(uint256 _amount) public onlyAdmin {\n        require(_amount > 0, \"Amount must be greater than zero\");\n        require(address(this).balance >= _amount, \"Insufficient contract balance\");\n        \n        payable(msg.sender).transfer(_amount);\n    }\n}", "idx": "223"}, {"project": "Contract224.sol", "commit_id": "0", "target": 1, "func": "pragma solidity ^0.8.0;\n\ncontract SecureCodeExample5 {\n    address private controller;\n\n    constructor() {\n        controller = msg.sender;\n    }\n\n    modifier onlyController() {\n        require(msg.sender == controller, \"Not the controller\");\n        _;\n    }\n\n    function changeController(address _newController) public onlyController {\n        require(_newController != address(0), \"Invalid new controller address\");\n        controller = _newController;\n    }\n\n    function withdrawFunds(uint256 _amount) public onlyController {\n        require(_amount > 0, \"Amount must be greater than zero\");\n        require(address(this).balance >= _amount, \"Insufficient contract balance\");\n        \n        payable(msg.sender).transfer(_amount);\n    }\n}", "idx": "224"}, {"project": "Contract225.sol", "commit_id": "0", "target": 1, "func": "pragma solidity ^0.8.0;\n\nlibrary SafeMath1 {\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(a + b >= a, \"SafeMath: addition overflow\");\n        return a + b;\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        return a - b;\n    }\n\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) return 0;\n        require(a * b / a == b, \"SafeMath: multiplication overflow\");\n        return a * b;\n    }\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: division by zero\");\n        return a / b;\n    }\n}\n\ncontract LargeNumbersDemo1 {\n    using SafeMath1 for uint256;\n\n    uint256 public result;\n\n    function addValues(uint256 a, uint256 b) public {\n        result = a.add(b);\n    }\n\n    function subtractValues(uint256 a, uint256 b) public {\n        result = a.sub(b);\n    }\n\n    function multiplyValues(uint256 a, uint256 b) public {\n        result = a.mul(b);\n    }\n\n    function divideValues(uint256 a, uint256 b) public {\n        result = a.div(b);\n    }\n}", "idx": "225"}, {"project": "Contract226.sol", "commit_id": "0", "target": 1, "func": "pragma solidity ^0.8.0;\n\nlibrary SafeMath2 {\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(a + b >= a, \"SafeMath: addition overflow\");\n        return a + b;\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        return a - b;\n    }\n\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) return 0;\n        require(a * b / a == b, \"SafeMath: multiplication overflow\");\n        return a * b;\n    }\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: division by zero\");\n        return a / b;\n    }\n}\n\ncontract LargeNumbersDemo2 {\n    using SafeMath2 for uint256;\n\n    uint256 public result;\n\n    function addValues(uint256 a, uint256 b) public {\n        result = a.add(b);\n    }\n\n    function subtractValues(uint256 a, uint256 b) public {\n        result = a.sub(b);\n    }\n\n    function multiplyValues(uint256 a, uint256 b) public {\n        result = a.mul(b);\n    }\n\n    function divideValues(uint256 a, uint256 b) public {\n        result = a.div(b);\n    }\n}", "idx": "226"}, {"project": "Contract227.sol", "commit_id": "0", "target": 1, "func": "pragma solidity ^0.8.0;\n\nlibrary SafeMath3 {\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(a + b >= a, \"SafeMath: addition overflow\");\n        return a + b;\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        return a - b;\n    }\n\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) return 0;\n        require(a * b / a == b, \"SafeMath: multiplication overflow\");\n        return a * b;\n    }\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: division by zero\");\n        return a / b;\n    }\n}\n\ncontract LargeNumbersDemo3 {\n    using SafeMath3 for uint256;\n\n    uint256 public result;\n\n    function addValues(uint256 a, uint256 b) public {\n        result = a.add(b);\n    }\n\n    function subtractValues(uint256 a, uint256 b) public {\n        result = a.sub(b);\n    }\n\n    function multiplyValues(uint256 a, uint256 b) public {\n        result = a.mul(b);\n    }\n\n    function divideValues(uint256 a, uint256 b) public {\n        result = a.div(b);\n    }\n}", "idx": "227"}, {"project": "Contract228.sol", "commit_id": "0", "target": 1, "func": "pragma solidity ^0.8.0;\n\nlibrary SafeMath4 {\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(a + b >= a, \"SafeMath: addition overflow\");\n        return a + b;\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        return a - b;\n    }\n\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) return 0;\n        require(a * b / a == b, \"SafeMath: multiplication overflow\");\n        return a * b;\n    }\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: division by zero\");\n        return a / b;\n    }\n}\n\ncontract LargeNumbersDemo4 {\n    using SafeMath4 for uint256;\n\n    uint256 public result;\n\n    function addValues(uint256 a, uint256 b) public {\n        result = a.add(b);\n    }\n\n    function subtractValues(uint256 a, uint256 b) public {\n        result = a.sub(b);\n    }\n\n    function multiplyValues(uint256 a, uint256 b) public {\n        result = a.mul(b);\n    }\n\n    function divideValues(uint256 a, uint256 b) public {\n        result = a.div(b);\n    }\n}", "idx": "228"}, {"project": "Contract229.sol", "commit_id": "0", "target": 1, "func": "pragma solidity ^0.8.0;\n\nlibrary SafeMath5 {\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(a + b >= a, \"SafeMath: addition overflow\");\n        return a + b;\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        return a - b;\n    }\n\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) return 0;\n        require(a * b / a == b, \"SafeMath: multiplication overflow\");\n        return a * b;\n    }\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: division by zero\");\n        return a / b;\n    }\n}\n\ncontract LargeNumbersDemo5 {\n    using SafeMath5 for uint256;\n    \n    uint256 public result;\n\n    function addValues(uint256 a, uint256 b) public {\n        result = a.add(b);\n    }\n\n    function subtractValues(uint256 a, uint256 b) public {\n        result = a.sub(b);\n    }\n\n    function multiplyValues(uint256 a, uint256 b) public {\n        result = a.mul(b);\n    }\n\n    function divideValues(uint256 a, uint256 b) public {\n        result = a.div(b);\n    }\n}", "idx": "229"}, {"project": "Contract230.sol", "commit_id": "0", "target": 1, "func": "pragma solidity ^0.8.0;\n\ncontract CrossChainCommunicationDemo {\n    mapping(address => uint256) public chainData;\n    address public oracleAddress;\n\n    event DataReceived(address indexed fromChain, uint256 data);\n\n    constructor(address _oracleAddress) {\n        oracleAddress = _oracleAddress;\n    }\n\n    function updateChainData(uint256 _data) public {\n        chainData[msg.sender] = _data;\n        emit DataReceived(msg.sender, _data);\n    }\n\n    function requestChainData() public {\n        uint256 data = chainData[msg.sender];\n        emit DataReceived(msg.sender, data);\n    }\n}", "idx": "230"}, {"project": "Contract231.sol", "commit_id": "0", "target": 1, "func": "pragma solidity ^0.8.0;\n\ncontract CrossChainCommunicationDemo1 {\n    mapping(address => uint256) public dataFromOtherChains;\n    address public oracle;\n\n    event DataReceived(address indexed fromChain, uint256 data);\n\n    constructor(address _oracle) {\n        oracle = _oracle;\n    }\n\n    function updateDataFromOtherChains(uint256 _data) public {\n        dataFromOtherChains[msg.sender] = _data;\n        emit DataReceived(msg.sender, _data);\n    }\n\n    function requestDataFromOtherChains() public {\n        uint256 data = dataFromOtherChains[msg.sender];\n        emit DataReceived(msg.sender, data);\n    }\n}", "idx": "231"}, {"project": "Contract232.sol", "commit_id": "0", "target": 1, "func": "pragma solidity ^0.8.0;\n\ncontract CrossChainCommunicationDemo2 {\n    mapping(address => uint256) public chainDataMapping;\n    address public oracleAddress;\n\n    event DataReceived(address indexed fromChain, uint256 data);\n\n    constructor(address _oracleAddress) {\n        oracleAddress = _oracleAddress;\n    }\n\n    function updateChainData(uint256 _data) public {\n        chainDataMapping[msg.sender] = _data;\n        emit DataReceived(msg.sender, _data);\n    }\n\n    function requestChainData() public {\n        uint256 data = chainDataMapping[msg.sender];\n        emit DataReceived(msg.sender, data);\n    }\n}", "idx": "232"}, {"project": "Contract233.sol", "commit_id": "0", "target": 1, "func": "pragma solidity ^0.8.0;\n\ncontract CrossChainCommunicationDemo3 {\n    mapping(address => uint256) public chainDataStorage;\n    address public oracleContract;\n\n    event DataReceived(address indexed fromChain, uint256 data);\n\n    constructor(address _oracleContract) {\n        oracleContract = _oracleContract;\n    }\n\n    function updateChainData(uint256 _data) public {\n        chainDataStorage[msg.sender] = _data;\n        emit DataReceived(msg.sender, _data);\n    }\n\n    function requestChainData() public {\n        uint256 data = chainDataStorage[msg.sender];\n        emit DataReceived(msg.sender, data);\n    }\n}", "idx": "233"}, {"project": "Contract234.sol", "commit_id": "0", "target": 1, "func": "pragma solidity ^0.8.0;\n\ncontract CrossChainDemo4 {\n    mapping(address => uint256) public data;\n    address public oracleAddress;\n\n    event DataReceived(address indexed fromChain, uint256 data);\n\n    constructor(address _oracleAddress) {\n        oracleAddress = _oracleAddress;\n    }\n\n    function updateData(uint256 _data) public {\n        data[msg.sender] = _data;\n        emit DataReceived(msg.sender, _data);\n    }\n\n    function requestData() public {\n        uint256 chainData = data[msg.sender];\n        emit DataReceived(msg.sender, chainData);\n    }\n}", "idx": "234"}, {"project": "Contract235.sol", "commit_id": "0", "target": 1, "func": "pragma solidity ^0.8.0;\n\ncontract CrossChainCommunicationDemo5 {\n    mapping(address => uint256) public chainData;\n    address public oracleContract;\n\n    event DataReceived(address indexed fromChain, uint256 data);\n\n    constructor(address _oracleContract) {\n        oracleContract = _oracleContract;\n    }\n\n    function updateDataFromOtherChains(uint256 _data) public {\n        chainData[msg.sender] = _data;\n        emit DataReceived(msg.sender, _data);\n    }\n\n    function requestDataFromOtherChains() public {\n        uint256 data = chainData[msg.sender];\n        emit DataReceived(msg.sender, data);\n    }\n}", "idx": "235"}, {"project": "Contract236.sol", "commit_id": "0", "target": 1, "func": "pragma solidity ^0.8.0;\n\ncontract SecurityTestingDemo {\n    address private owner;\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Not the contract owner\");\n        _;\n    }\n\n    function changeOwner(address _newOwner) public onlyOwner {\n        require(_newOwner != address(0), \"Invalid new owner address\");\n        owner = _newOwner;\n    }\n\n    function deposit() public payable {}\n\n    function withdraw(uint256 _amount) public onlyOwner {\n        require(_amount > 0, \"Amount must be greater than zero\");\n        require(address(this).balance >= _amount, \"Insufficient contract balance\");\n\n        payable(msg.sender).transfer(_amount);\n    }\n}", "idx": "236"}, {"project": "Contract237.sol", "commit_id": "0", "target": 1, "func": "pragma solidity ^0.8.0;\n\ncontract SecurityTestingDemo1 {\n    address private contractOwner;\n\n    constructor() {\n        contractOwner = msg.sender;\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == contractOwner, \"Not the contract owner\");\n        _;\n    }\n\n    function changeContractOwner(address _newOwner) public onlyOwner {\n        require(_newOwner != address(0), \"Invalid new owner address\");\n        contractOwner = _newOwner;\n    }\n\n    function depositFunds() public payable {}\n\n    function withdrawFunds(uint256 _amount) public onlyOwner {\n        require(_amount > 0, \"Amount must be greater than zero\");\n        require(address(this).balance >= _amount, \"Insufficient contract balance\");\n\n        payable(msg.sender).transfer(_amount);\n    }\n}", "idx": "237"}, {"project": "Contract238.sol", "commit_id": "0", "target": 1, "func": "pragma solidity ^0.8.0;\n\ncontract SecurityTestingDemo2 {\n    address private contractAdmin;\n\n    constructor() {\n        contractAdmin = msg.sender;\n    }\n\n    modifier onlyAdmin() {\n        require(msg.sender == contractAdmin, \"Not the contract admin\");\n        _;\n    }\n\n    function changeAdmin(address _newAdmin) public onlyAdmin {\n        require(_newAdmin != address(0), \"Invalid new admin address\");\n        contractAdmin = _newAdmin;\n    }\n\n    function depositFunds() public payable {}\n\n    function withdrawFunds(uint256 _amount) public onlyAdmin {\n        require(_amount > 0, \"Amount must be greater than zero\");\n        require(address(this).balance >= _amount, \"Insufficient contract balance\");\n\n        payable(msg.sender).transfer(_amount);\n    }\n}", "idx": "238"}, {"project": "Contract239.sol", "commit_id": "0", "target": 1, "func": "pragma solidity ^0.8.0;\n\ncontract SecurityTestingDemo3 {\n    address private controller;\n\n    constructor() {\n        controller = msg.sender;\n    }\n\n    modifier onlyController() {\n        require(msg.sender == controller, \"Not the controller\");\n        _;\n    }\n\n    function changeController(address _newController) public onlyController {\n        require(_newController != address(0), \"Invalid new controller address\");\n        controller = _newController;\n    }\n\n    function depositFunds() public payable {}\n\n    function withdrawFunds(uint256 _amount) public onlyController {\n        require(_amount > 0, \"Amount must be greater than zero\");\n        require(address(this).balance >= _amount, \"Insufficient contract balance\");\n\n        payable(msg.sender).transfer(_amount);\n    }\n}", "idx": "239"}, {"project": "Contract240.sol", "commit_id": "0", "target": 1, "func": "pragma solidity ^0.8.0;\n\ncontract SecurityTestingDemo4 {\n    address private ownerOfContract;\n\n    constructor() {\n        ownerOfContract = msg.sender;\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == ownerOfContract, \"Not the contract owner\");\n        _;\n    }\n\n    function changeContractOwner(address _newOwner) public onlyOwner {\n        require(_newOwner != address(0), \"Invalid new owner address\");\n        ownerOfContract = _newOwner;\n    }\n\n    function depositFunds() public payable {}\n\n    function withdrawFunds(uint256 _amount) public onlyOwner {\n        require(_amount > 0, \"Amount must be greater than zero\");\n        require(address(this).balance >= _amount, \"Insufficient contract balance\");\n\n        payable(msg.sender).transfer(_amount);\n    }\n}", "idx": "240"}, {"project": "Contract241.sol", "commit_id": "0", "target": 1, "func": "pragma solidity ^0.8.0;\n\ncontract SecurityTestingDemo5 {\n    address private admin;\n\n    constructor() {\n        admin = msg.sender;\n    }\n\n    modifier onlyAdmin() {\n        require(msg.sender == admin, \"Not the admin\");\n        _;\n    }\n\n    function changeAdmin(address _newAdmin) public onlyAdmin {\n        require(_newAdmin != address(0), \"Invalid new admin address\");\n        admin = _newAdmin;\n    }\n\n    function depositFunds() public payable {}\n\n    function withdrawFunds(uint256 _amount) public onlyAdmin {\n        require(_amount > 0, \"Amount must be greater than zero\");\n        require(address(this).balance >= _amount, \"Insufficient contract balance\");\n\n        payable(msg.sender).transfer(_amount);\n    }\n}", "idx": "241"}, {"project": "Contract242.sol", "commit_id": "0", "target": 1, "func": "pragma solidity ^0.8.0;\n\ncontract CryptographicDemo {\n    uint256 private secretNumber;\n    address private owner;\n\n    event SecretNumberUpdated(uint256 newSecretNumber);\n\n    constructor(uint256 _initialSecretNumber) {\n        secretNumber = _initialSecretNumber;\n        owner = msg.sender;\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Not the contract owner\");\n        _;\n    }\n\n    function updateSecretNumber(uint256 _newSecretNumber) public onlyOwner {\n        secretNumber = _newSecretNumber;\n        emit SecretNumberUpdated(_newSecretNumber);\n    }\n\n    function getSecretNumber() public view returns (uint256) {\n        return secretNumber;\n    }\n\n    function validateSecretNumber(uint256 _guess) public view returns (bool) {\n        return _guess == secretNumber;\n    }\n}", "idx": "242"}, {"project": "Contract243.sol", "commit_id": "0", "target": 1, "func": "pragma solidity ^0.8.0;\n\ncontract CryptographicDemo1 {\n    uint256 private privateKey;\n    address private contractOwner;\n\n    event PrivateKeyUpdated(uint256 newPrivateKey);\n\n    constructor(uint256 _initialPrivateKey) {\n        privateKey = _initialPrivateKey;\n        contractOwner = msg.sender;\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == contractOwner, \"Not the contract owner\");\n        _;\n    }\n\n    function updatePrivateKey(uint256 _newPrivateKey) public onlyOwner {\n        privateKey = _newPrivateKey;\n        emit PrivateKeyUpdated(_newPrivateKey);\n    }\n\n    function getPrivateKey() public view returns (uint256) {\n        return privateKey;\n    }\n\n    function validatePrivateKey(uint256 _guess) public view returns (bool) {\n        return _guess == privateKey;\n    }\n}", "idx": "243"}, {"project": "Contract244.sol", "commit_id": "0", "target": 1, "func": "pragma solidity ^0.8.0;\n\ncontract CryptographicDemo2 {\n    bytes32 private secretHash;\n    address private owner;\n\n    event SecretHashUpdated(bytes32 newSecretHash);\n\n    constructor(bytes32 _initialSecretHash) {\n        secretHash = _initialSecretHash;\n        owner = msg.sender;\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Not the contract owner\");\n        _;\n    }\n\n    function updateSecretHash(bytes32 _newSecretHash) public onlyOwner {\n        secretHash = _newSecretHash;\n        emit SecretHashUpdated(_newSecretHash);\n    }\n\n    function getSecretHash() public view returns (bytes32) {\n        return secretHash;\n    }\n\n    function validateSecretHash(bytes32 _guess) public view returns (bool) {\n        return _guess == secretHash;\n    }\n}", "idx": "244"}, {"project": "Contract245.sol", "commit_id": "0", "target": 1, "func": "pragma solidity ^0.8.0;\n\ncontract CryptographicDemo3 {\n    uint256 private encryptionKey;\n    address private admin;\n\n    event EncryptionKeyUpdated(uint256 newEncryptionKey);\n\n    constructor(uint256 _initialEncryptionKey) {\n        encryptionKey = _initialEncryptionKey;\n        admin = msg.sender;\n    }\n\n    modifier onlyAdmin() {\n        require(msg.sender == admin, \"Not the admin\");\n        _;\n    }\n\n    function updateEncryptionKey(uint256 _newEncryptionKey) public onlyAdmin {\n        encryptionKey = _newEncryptionKey;\n        emit EncryptionKeyUpdated(_newEncryptionKey);\n    }\n\n    function getEncryptionKey() public view returns (uint256) {\n        return encryptionKey;\n    }\n\n    function validateEncryptionKey(uint256 _guess) public view returns (bool) {\n        return _guess == encryptionKey;\n    }\n}", "idx": "245"}, {"project": "Contract246.sol", "commit_id": "0", "target": 1, "func": "pragma solidity ^0.8.0;\n\ncontract CryptographicDemo4 {\n    string private encryptionAlgorithm;\n    address private contractAdmin;\n\n    event EncryptionAlgorithmUpdated(string newEncryptionAlgorithm);\n\n    constructor(string memory _initialEncryptionAlgorithm) {\n        encryptionAlgorithm = _initialEncryptionAlgorithm;\n        contractAdmin = msg.sender;\n    }\n\n    modifier onlyAdmin() {\n        require(msg.sender == contractAdmin, \"Not the admin\");\n        _;\n    }\n\n    function updateEncryptionAlgorithm(string memory _newEncryptionAlgorithm) public onlyAdmin {\n        encryptionAlgorithm = _newEncryptionAlgorithm;\n        emit EncryptionAlgorithmUpdated(_newEncryptionAlgorithm);\n    }\n\n    function getEncryptionAlgorithm() public view returns (string memory) {\n        return encryptionAlgorithm;\n    }\n}", "idx": "246"}, {"project": "Contract247.sol", "commit_id": "0", "target": 1, "func": "pragma solidity ^0.8.0;\n\ncontract CryptographicDemo5 {\n    bytes32 private messageDigest;\n    address private adminAddress;\n\n    event MessageDigestUpdated(bytes32 newMessageDigest);\n\n    constructor(bytes32 _initialMessageDigest) {\n        messageDigest = _initialMessageDigest;\n        adminAddress = msg.sender;\n    }\n\n    modifier onlyAdmin() {\n        require(msg.sender == adminAddress, \"Not the admin\");\n        _;\n    }\n\n    function updateMessageDigest(bytes32 _newMessageDigest) public onlyAdmin {\n        messageDigest = _newMessageDigest;\n        emit MessageDigestUpdated(_newMessageDigest);\n    }\n\n    function getMessageDigest() public view returns (bytes32) {\n        return messageDigest;\n    }\n}", "idx": "247"}, {"project": "Contract248.sol", "commit_id": "0", "target": 1, "func": "pragma solidity ^0.8.0;\n\ncontract CryptographicDemo6 {\n    uint256 private verificationCode;\n    address private admin;\n\n    event VerificationCodeUpdated(uint256 newVerificationCode);\n\n    constructor(uint256 _initialVerificationCode) {\n        verificationCode = _initialVerificationCode;\n        admin = msg.sender;\n    }\n\n    modifier onlyAdmin() {\n        require(msg.sender == admin, \"Not the admin\");\n        _;\n    }\n\n    function updateVerificationCode(uint256 _newVerificationCode) public onlyAdmin {\n        verificationCode = _newVerificationCode;\n        emit VerificationCodeUpdated(_newVerificationCode);\n    }\n\n    function getVerificationCode() public view returns (uint256) {\n        return verificationCode;\n    }\n\n    function validateVerificationCode(uint256 _guess) public view returns (bool) {\n        return _guess == verificationCode;\n    }\n}", "idx": "248"}, {"project": "Contract249.sol", "commit_id": "0", "target": 1, "func": "pragma solidity ^0.8.0;\n\ncontract InteroperabilitySmartContract {\n    address public crossChainBridge;\n    uint public depositedAmount;\n\n    constructor(address _crossChainBridge) {\n        crossChainBridge = _crossChainBridge;\n    }\n\n    function depositEther(uint _amount) public payable {\n        require(msg.value == _amount, \"Incorrect Ether amount provided\");\n        depositedAmount += _amount;\n        require(crossChainBridge.call{value: _amount}(\"\"), \"Cross-chain transaction failed\");\n    }\n\n    function withdrawEther() public {\n        uint amountToWithdraw = depositedAmount;\n        depositedAmount = 0;\n        require(crossChainBridge.call{value: amountToWithdraw}(\"\"), \"Cross-chain withdrawal failed\");\n        payable(msg.sender).transfer(amountToWithdraw);\n    }\n}", "idx": "249"}, {"project": "Contract250.sol", "commit_id": "0", "target": 1, "func": "pragma solidity ^0.8.0;\n\ncontract InteroperabilitySmartContract {\n    address public crossChainBridge;\n    uint public depositedAmount;\n\n    constructor(address _bridge) {\n        crossChainBridge = _bridge;\n    }\n\n    function depositEther(uint _amount) public payable {\n        require(msg.value == _amount, \"Invalid Ether amount\");\n        depositedAmount += _amount;\n        require(crossChainBridge.call{value: _amount}(\"\"), \"Cross-chain transaction failed\");\n    }\n\n    function withdrawEther() public {\n        uint amountToWithdraw = depositedAmount;\n        depositedAmount = 0;\n        require(crossChainBridge.call{value: amountToWithdraw}(\"\"), \"Cross-chain withdrawal failed\");\n        payable(msg.sender).transfer(amountToWithdraw);\n    }\n}", "idx": "250"}, {"project": "Contract251.sol", "commit_id": "0", "target": 1, "func": "pragma solidity ^0.8.0;\n\ncontract InteroperabilitySmartContract {\n    address public crossChainBridge;\n    uint public depositedAmount;\n\n    event EtherDeposited(uint amount);\n\n    constructor(address _bridge) {\n        crossChainBridge = _bridge;\n    }\n\n    function depositEther(uint _amount) public payable {\n        require(msg.value == _amount, \"Invalid Ether amount\");\n        depositedAmount += _amount;\n        emit EtherDeposited(_amount);\n        require(crossChainBridge.call{value: _amount}(\"\"), \"Cross-chain transaction failed\");\n    }\n\n    function withdrawEther() public {\n        uint amountToWithdraw = depositedAmount;\n        depositedAmount = 0;\n        require(crossChainBridge.call{value: amountToWithdraw}(\"\"), \"Cross-chain withdrawal failed\");\n        payable(msg.sender).transfer(amountToWithdraw);\n    }\n}", "idx": "251"}, {"project": "Contract252.sol", "commit_id": "0", "target": 1, "func": "pragma solidity ^0.8.0;\n\ncontract InteroperabilitySmartContract {\n    address public crossChainBridge;\n    uint public depositedAmount;\n\n    constructor(address _bridge) {\n        crossChainBridge = _bridge;\n    }\n\n    function depositEther(uint _amount) public payable {\n        require(msg.value == _amount, \"Invalid Ether amount\");\n        depositedAmount += _amount;\n        require(crossChainBridge.call{value: _amount}(\"\"), \"Cross-chain transaction failed\");\n    }\n\n    function withdrawEther() public {\n        uint amountToWithdraw = depositedAmount;\n        depositedAmount = 0;\n        require(crossChainBridge.call{value: amountToWithdraw}(\"\"), \"Cross-chain withdrawal failed\");\n        payable(msg.sender).transfer(amountToWithdraw);\n    }\n\n    function getDepositedAmount() public view returns (uint) {\n        return depositedAmount;\n    }\n}", "idx": "252"}, {"project": "Contract253.sol", "commit_id": "0", "target": 1, "func": "pragma solidity ^0.8.0;\n\ncontract InteroperabilitySmartContract {\n    address public crossChainBridge;\n    uint public depositedAmount;\n\n    constructor(address _bridge) {\n        crossChainBridge = _bridge;\n    }\n\n    function depositEther(uint _amount) public payable {\n        require(msg.value == _amount, \"Invalid Ether amount\");\n        depositedAmount += _amount;\n        require(crossChainBridge.call{value: _amount}(\"\"), \"Cross-chain transaction failed\");\n    }\n\n    function withdrawEther() public {\n        uint amountToWithdraw = depositedAmount;\n        depositedAmount = 0;\n        require(crossChainBridge.call{value: amountToWithdraw}(\"\"), \"Cross-chain withdrawal failed\");\n        payable(msg.sender).transfer(amountToWithdraw);\n    }\n\n    function getBridgeAddress() public view returns (address) {\n        return crossChainBridge;\n    }\n}", "idx": "253"}, {"project": "Contract254.sol", "commit_id": "0", "target": 1, "func": "pragma solidity ^0.8.0;\n\ncontract InteroperabilitySmartContract {\n    address public crossChainBridge;\n    uint public depositedAmount;\n\n    constructor(address _bridge) {\n        crossChainBridge = _bridge;\n    }\n\n    function depositEther(uint _amount) public payable {\n        require(msg.value == _amount, \"Invalid Ether amount\");\n        depositedAmount += _amount;\n        require(crossChainBridge.call{value: _amount}(\"\"), \"Cross-chain transaction failed\");\n    }\n\n    function withdrawEther() public {\n        uint amountToWithdraw = depositedAmount;\n        depositedAmount = 0;\n        require(crossChainBridge.call{value: amountToWithdraw}(\"\"), \"Cross-chain withdrawal failed\");\n        payable(msg.sender).transfer(amountToWithdraw);\n    }\n\n    function setBridgeAddress(address _newBridge) public {\n        crossChainBridge = _newBridge;\n    }\n}", "idx": "254"}, {"project": "Contract255.sol", "commit_id": "0", "target": 1, "func": "pragma solidity ^0.8.0;\n\ncontract InteroperabilitySmartContract {\n    address public crossChainBridge;\n    uint public depositedAmount;\n\n    constructor(address _bridge) {\n        crossChainBridge = _bridge;\n    }\n\n    function depositEther(uint _amount) public payable {\n        require(msg.value == _amount, \"Invalid Ether amount\");\n        depositedAmount += _amount;\n        require(crossChainBridge.call{value: _amount}(\"\"), \"Cross-chain transaction failed\");\n    }\n\n    function withdrawEther() public {\n        uint amountToWithdraw = depositedAmount;\n        depositedAmount = 0;\n        require(crossChainBridge.call{value: amountToWithdraw}(\"\"), \"Cross-chain withdrawal failed\");\n        payable(msg.sender).transfer(amountToWithdraw);\n    }\n\n    function isBridgeActive() public view returns (bool) {\n        // Simplified condition for demonstration\n        return crossChainBridge != address(0);\n    }\n}", "idx": "255"}, {"project": "Contract256.sol", "commit_id": "0", "target": 1, "func": "pragma solidity ^0.8.0;\n\ncontract InteroperabilitySmartContract {\n    address public crossChainBridge;\n    uint public depositedAmount;\n\n    constructor(address _bridge) {\n        crossChainBridge = _bridge;\n    }\n\n    function depositEther(uint _amount) public payable {\n        require(msg.value == _amount, \"Invalid Ether amount\");\n        depositedAmount += _amount;\n        require(crossChainBridge.call{value: _amount}(\"\"), \"Cross-chain transaction failed\");\n    }\n\n    function withdrawEther() public {\n        uint amountToWithdraw = depositedAmount;\n        depositedAmount = 0;\n        require(crossChainBridge.call{value: amountToWithdraw}(\"\"), \"Cross-chain withdrawal failed\");\n        payable(msg.sender).transfer(amountToWithdraw);\n    }\n\n    function updateBridgeAddress(address _newBridge) public {\n        require(_newBridge != address(0), \"Invalid bridge address\");\n        crossChainBridge = _newBridge;\n    }\n}", "idx": "256"}, {"project": "Contract257.sol", "commit_id": "0", "target": 1, "func": "pragma solidity ^0.8.0;\n\ncontract DoubleSpendingSmartContract {\n    mapping(address => uint) public balances;\n\n    function deposit() public payable {\n        require(msg.value > 0, \"Deposit amount must be greater than 0\");\n        balances[msg.sender] += msg.value;\n    }\n\n    function withdraw(uint _amount) public {\n        require(_amount > 0, \"Withdrawal amount must be greater than 0\");\n        require(balances[msg.sender] >= _amount, \"Insufficient balance\");\n\n        uint balance = balances[msg.sender];\n        balances[msg.sender] -= _amount;\n        externalCall(msg.sender, _amount);\n\n        payable(msg.sender).transfer(_amount);\n\n        balances[msg.sender] = balance;\n    }\n\n    function externalCall(address _recipient, uint _amount) internal {\n        ReentrancyVulnerableContract(_recipient).receiveFunds(_amount);\n    }\n}\n\ncontract ReentrancyVulnerableContract {\n    mapping(address => uint) public balances;\n\n    function receiveFunds(uint _amount) public {\n        require(_amount > 0, \"Amount must be greater than 0\");\n\n        balances[msg.sender] += _amount;\n        DoubleSpendingSmartContract(msg.sender).withdraw(_amount);\n    }\n}", "idx": "257"}, {"project": "Contract258.sol", "commit_id": "0", "target": 1, "func": "pragma solidity ^0.8.0;\n\ncontract DoubleSpendingSmartContract {\n    mapping(address => uint) public balances;\n\n    function deposit() public payable {\n        require(msg.value > 0, \"Invalid deposit amount\");\n        balances[msg.sender] += msg.value;\n    }\n\n    function tryWithdraw(uint _amount) public {\n        require(_amount > 0, \"Invalid withdrawal amount\");\n        require(balances[msg.sender] >= _amount, \"Insufficient balance\");\n        balances[msg.sender] -= _amount;\n        externalCall(msg.sender, _amount);\n        payable(msg.sender).transfer(_amount);\n    }\n\n    function externalCall(address _recipient, uint _amount) internal {\n        ReentrancyVulnerableContract(_recipient).receiveFunds(_amount);\n    }\n}\n\ncontract ReentrancyVulnerableContract {\n    mapping(address => uint) public balances;\n\n    function receiveFunds(uint _amount) public {\n        require(_amount > 0, \"Invalid amount\");\n        balances[msg.sender] += _amount;\n        DoubleSpendingSmartContract(msg.sender).tryWithdraw(_amount);\n    }\n}", "idx": "258"}, {"project": "Contract259.sol", "commit_id": "0", "target": 1, "func": "pragma solidity ^0.8.0;\n\ncontract DoubleSpendingSmartContract {\n    mapping(address => uint) public balances;\n    mapping(address => uint) public rewards;\n\n    function deposit() public payable {\n        require(msg.value > 0, \"Invalid deposit amount\");\n        balances[msg.sender] += msg.value;\n    }\n\n    function tryWithdraw(uint _amount) public {\n        require(_amount > 0, \"Invalid withdrawal amount\");\n        require(balances[msg.sender] >= _amount, \"Insufficient balance\");\n        balances[msg.sender] -= _amount;\n        rewards[msg.sender] += _amount * 2;  \n        externalCall(msg.sender, _amount);\n        payable(msg.sender).transfer(_amount);\n    }\n\n    function externalCall(address _recipient, uint _amount) internal {\n        ReentrancyVulnerableContract(_recipient).receiveFunds(_amount);\n    }\n}\n\ncontract ReentrancyVulnerableContract {\n    mapping(address => uint) public balances;\n\n    function receiveFunds(uint _amount) public {\n        require(_amount > 0, \"Invalid amount\");\n        balances[msg.sender] += _amount;\n        DoubleSpendingSmartContract(msg.sender).tryWithdraw(_amount);\n    }\n}", "idx": "259"}, {"project": "Contract260.sol", "commit_id": "0", "target": 1, "func": "pragma solidity ^0.8.0;\n\ncontract DoubleSpendingSmartContract {\n    mapping(address => uint) public balances;\n    mapping(address => uint) public rewards;\n\n    function deposit() public payable {\n        require(msg.value > 0, \"Invalid deposit amount\");\n        balances[msg.sender] += msg.value;\n    }\n\n    function tryWithdraw(uint _amount) public {\n        require(_amount > 0, \"Invalid withdrawal amount\");\n        require(balances[msg.sender] >= _amount, \"Insufficient balance\");\n        balances[msg.sender] -= _amount;\n        rewards[msg.sender] += _amount * 2;\n        externalCall(msg.sender, _amount);\n        payable(msg.sender).transfer(_amount);\n    }\n\n    function externalCall(address _recipient, uint _amount) internal {\n        ReentrancyVulnerableContract(_recipient).receiveFunds(_amount);\n    }\n}\n\ncontract ReentrancyVulnerableContract {\n    mapping(address => uint) public balances;\n\n    function receiveFunds(uint _amount) public {\n        require(_amount > 0, \"Invalid amount\");\n        balances[msg.sender] += _amount;\n        DoubleSpendingSmartContract(msg.sender).tryWithdraw(_amount);\n    }\n}", "idx": "260"}, {"project": "Contract261.sol", "commit_id": "0", "target": 1, "func": "pragma solidity ^0.8.0;\n\ncontract DoubleSpendingSmartContract {\n    mapping(address => uint) public balances;\n\n    function deposit() public payable {\n        require(msg.value > 0, \"Invalid deposit amount\");\n        balances[msg.sender] += msg.value;\n    }\n\n    function tryWithdraw(uint _amount) public {\n        require(_amount > 0, \"Invalid withdrawal amount\");\n        require(balances[msg.sender] >= _amount, \"Insufficient balance\");\n        balances[msg.sender] -= _amount;\n        // Simulated external call\n        externalCall(msg.sender, _amount);\n        // Actual transfer\n        payable(msg.sender).transfer(_amount);\n    }\n\n    function externalCall(address _recipient, uint _amount) internal {\n        ReentrancyVulnerableContract(_recipient).receiveFunds(_amount);\n    }\n}\n\ncontract ReentrancyVulnerableContract {\n    mapping(address => uint) public balances;\n\n    function receiveFunds(uint _amount) public {\n        require(_amount > 0, \"Invalid amount\");\n        balances[msg.sender] += _amount;\n        DoubleSpendingSmartContract(msg.sender).tryWithdraw(_amount);\n    }\n}", "idx": "261"}, {"project": "Contract262.sol", "commit_id": "0", "target": 1, "func": "pragma solidity ^0.8.0;\n\ncontract DoubleSpendingSmartContract {\n    mapping(address => uint) public balances;\n\n    function deposit() public payable {\n        require(msg.value > 0, \"Invalid deposit amount\");\n        balances[msg.sender] += msg.value;\n    }\n\n    function tryWithdraw(uint _amount) public {\n        require(_amount > 0, \"Invalid withdrawal amount\");\n        require(balances[msg.sender] >= _amount, \"Insufficient balance\");\n        balances[msg.sender] -= _amount;\n        // Simulated external call\n        externalCall(msg.sender, _amount);\n        // Actual transfer\n        payable(msg.sender).transfer(_amount);\n    }\n\n    function externalCall(address _recipient, uint _amount) internal {\n        ReentrancyVulnerableContract(_recipient).receiveFunds(_amount);\n    }\n}\n\ncontract ReentrancyVulnerableContract {\n    mapping(address => uint) public balances;\n\n    function receiveFunds(uint _amount) public {\n        require(_amount > 0, \"Invalid amount\");\n        balances[msg.sender] += _amount;\n        DoubleSpendingSmartContract(msg.sender).tryWithdraw(_amount);\n    }\n}", "idx": "262"}, {"project": "Contract263.sol", "commit_id": "0", "target": 1, "func": "pragma solidity ^0.8.0;\n\ncontract DoubleSpendingSmartContract {\n    mapping(address => uint) public balances;\n    mapping(address => uint) public withdrawalUnlockTime;\n\n    function deposit() public payable {\n        require(msg.value > 0, \"Invalid deposit amount\");\n        balances[msg.sender] += msg.value;\n    }\n\n    function initiateWithdrawal(uint _amount) public {\n        require(_amount > 0, \"Invalid withdrawal amount\");\n        require(balances[msg.sender] >= _amount, \"Insufficient balance\");\n\n        // Set a time lock of 10 seconds for the withdrawal\n        uint unlockTime = block.timestamp + 10;\n        withdrawalUnlockTime[msg.sender] = unlockTime;\n    }\n\n    function completeWithdrawal(uint _amount) public {\n        require(withdrawalUnlockTime[msg.sender] != 0, \"Withdrawal not initiated\");\n        require(block.timestamp >= withdrawalUnlockTime[msg.sender], \"Withdrawal is still time-locked\");\n\n        balances[msg.sender] -= _amount;\n        // Simulated external call\n        externalCall(msg.sender, _amount);\n        // Actual transfer\n        payable(msg.sender).transfer(_amount);\n\n        // Reset the time lock after successful withdrawal\n        withdrawalUnlockTime[msg.sender] = 0;\n    }\n\n    function externalCall(address _recipient, uint _amount) internal {\n        ReentrancyVulnerableContract(_recipient).receiveFunds(_amount);\n    }\n}\n\ncontract ReentrancyVulnerableContract {\n    mapping(address => uint) public balances;\n\n    function receiveFunds(uint _amount) public {\n        require(_amount > 0, \"Invalid amount\");\n        balances[msg.sender] += _amount;\n        DoubleSpendingSmartContract(msg.sender).completeWithdrawal(_amount);\n    }\n}", "idx": "263"}, {"project": "Contract264.sol", "commit_id": "0", "target": 1, "func": "pragma solidity ^0.8.0;\n\ncontract FrontRunningVulnerableContract {\n    mapping(address => uint) public balances;\n\n    function buyTokens(uint _amount) public payable {\n        require(_amount > 0, \"Invalid token amount\");\n        require(msg.value >= _amount * 1 ether, \"Insufficient Ether sent\");\n\n        uint tokensToTransfer = _amount;\n\n        balances[msg.sender] += tokensToTransfer;\n    }\n}", "idx": "264"}, {"project": "Contract265.sol", "commit_id": "0", "target": 1, "func": "pragma solidity ^0.8.0;\n\ncontract FrontRunningVulnerableContract {\n    mapping(address => uint) public balances;\n\n    function buyTokens(uint _amount) public payable {\n        require(_amount > 0, \"Invalid token amount\");\n        require(msg.value >= _amount * 1 ether, \"Insufficient Ether sent\");\n\n        uint tokensToTransfer = _amount;\n        balances[msg.sender] += tokensToTransfer;\n    }\n}", "idx": "265"}, {"project": "Contract266.sol", "commit_id": "0", "target": 1, "func": "pragma solidity ^0.8.0;\n\ncontract FrontRunningVulnerableContract {\n    mapping(address => uint) public balances;\n    uint public deadline;\n\n    function buyTokens(uint _amount) public payable {\n        require(_amount > 0, \"Invalid token amount\");\n        require(msg.value >= _amount * 1 ether, \"Insufficient Ether sent\");\n        require(block.timestamp <= deadline, \"Transaction expired\");\n\n        uint tokensToTransfer = _amount;\n        balances[msg.sender] += tokensToTransfer;\n    }\n}", "idx": "266"}, {"project": "Contract267.sol", "commit_id": "0", "target": 1, "func": "pragma solidity ^0.8.0;\n\ncontract FrontRunningVulnerableContract {\n    mapping(address => uint) public balances;\n    uint public tokenPrice;\n\n    function buyTokens(uint _amount) public payable {\n        require(_amount > 0, \"Invalid token amount\");\n        require(msg.value >= _amount * tokenPrice, \"Insufficient Ether sent\");\n\n        uint tokensToTransfer = _amount;\n        balances[msg.sender] += tokensToTransfer;\n    }\n}", "idx": "267"}, {"project": "Contract268.sol", "commit_id": "0", "target": 1, "func": "pragma solidity ^0.8.0;\n\ncontract FrontRunningVulnerableContract {\n    mapping(address => uint) public balances;\n\n    function buyTokens(address _tokenContract, uint _amount) public payable {\n        require(_amount > 0, \"Invalid token amount\");\n        require(msg.value >= _amount * 1 ether, \"Insufficient Ether sent\");\n\n        // Assume a function in the _tokenContract that transfers tokens\n        // Vulnerability lies in the fact that an attacker can front-run this external call\n        _tokenContract.call(abi.encodeWithSignature(\"transfer(address,uint256)\", msg.sender, _amount));\n        balances[msg.sender] += _amount;\n    }\n}", "idx": "268"}, {"project": "Contract269.sol", "commit_id": "0", "target": 1, "func": "pragma solidity ^0.8.0;\n\ncontract FrontRunningVulnerableContract {\n    mapping(address => uint) public balances;\n    uint public constant TOKEN_PRICE = 2 ether;\n\n    function buyTokens(uint _amount) public payable {\n        require(_amount > 0, \"Invalid token amount\");\n        require(msg.value >= _amount * TOKEN_PRICE, \"Insufficient Ether sent\");\n\n        uint tokensToTransfer = _amount;\n        balances[msg.sender] += tokensToTransfer;\n    }\n}", "idx": "269"}, {"project": "Contract270.sol", "commit_id": "0", "target": 1, "func": "pragma solidity ^0.8.0;\n\ncontract FrontRunningVulnerableContract {\n    mapping(address => uint) public balances;\n    uint public lotteryNumber;\n\n    function buyLotteryTicket(uint _number) public payable {\n        require(_number > 0, \"Invalid lottery number\");\n        require(msg.value == 1 ether, \"Incorrect Ether amount\");\n\n        if (_number == lotteryNumber) {\n            // Assume winner receives 10 ether\n            payable(msg.sender).transfer(10 ether);\n        }\n\n        balances[msg.sender] += 1;\n    }\n\n    function setLotteryNumber(uint _newNumber) public {\n        lotteryNumber = _newNumber;\n    }\n}", "idx": "270"}, {"project": "Contract271.sol", "commit_id": "0", "target": 1, "func": "pragma solidity ^0.8.0;\n\ncontract FrontRunningVulnerableContract {\n    mapping(address => uint) public highestBid;\n\n    function bid() public payable {\n        require(msg.value > highestBid[msg.sender], \"Bid not high enough\");\n\n        uint previousHighestBid = highestBid[msg.sender];\n        highestBid[msg.sender] = msg.value;\n\n        // Transfer the previous highest bid back to the user\n        payable(msg.sender).transfer(previousHighestBid);\n    }\n}", "idx": "271"}, {"project": "Contract272.sol", "commit_id": "0", "target": 1, "func": "pragma solidity ^0.8.0;\n\ncontract TransactionMalleabilityContract {\n    event MessageHash(bytes32 hash);\n\n    function generateHash(string memory _message) public {\n        bytes32 hash = keccak256(abi.encodePacked(_message));\n        emit MessageHash(hash);\n    }\n}", "idx": "272"}, {"project": "Contract273.sol", "commit_id": "0", "target": 1, "func": "pragma solidity ^0.8.0;\n\ncontract TransactionMalleabilityContract {\n    event MessageHash(bytes32 hash);\n    uint public counter;\n\n    function generateHash(string memory _message) public {\n        bytes32 hash = keccak256(abi.encodePacked(_message, counter));\n        counter++;\n        emit MessageHash(hash);\n    }\n}", "idx": "273"}, {"project": "Contract274.sol", "commit_id": "0", "target": 1, "func": "pragma solidity ^0.8.0;\n\ncontract TransactionMalleabilityContract {\n    event MessageHash(bytes32 hash);\n    uint public totalFees;\n\n    function generateHash(string memory _message, uint _fee) public payable {\n        require(msg.value >= _fee, \"Insufficient fee\");\n        bytes32 hash = keccak256(abi.encodePacked(_message));\n        totalFees += _fee;\n        emit MessageHash(hash);\n    }\n}", "idx": "274"}, {"project": "Contract275.sol", "commit_id": "0", "target": 1, "func": "pragma solidity ^0.8.0;\n\ncontract TransactionMalleabilityContract {\n    event MessageHash(bytes32 hash);\n    mapping(address => uint) public userCounter;\n\n    function generateHash(string memory _message) public {\n        bytes32 hash = keccak256(abi.encodePacked(_message, userCounter[msg.sender]));\n        userCounter[msg.sender]++;\n        emit MessageHash(hash);\n    }\n}", "idx": "275"}, {"project": "Contract276.sol", "commit_id": "0", "target": 1, "func": "pragma solidity ^0.8.0;\n\ncontract TransactionMalleabilityContract {\n    event MessageHash(bytes32 hash);\n\n    function generateHash(string memory _message) public {\n        require(block.timestamp % 2 == 0, \"Not an even timestamp\");\n        bytes32 hash = keccak256(abi.encodePacked(_message));\n        emit MessageHash(hash);\n    }\n}", "idx": "276"}, {"project": "Contract277.sol", "commit_id": "0", "target": 1, "func": "pragma solidity ^0.8.0;\n\ncontract TransactionMalleabilityContract {\n    event MessageHash(bytes32 hash);\n\n    function generateHash(string memory _message) public {\n        require(gasleft() % 2 == 0, \"Not enough gas\");\n        bytes32 hash = keccak256(abi.encodePacked(_message));\n        emit MessageHash(hash);\n    }\n}", "idx": "277"}, {"project": "Contract278.sol", "commit_id": "0", "target": 1, "func": "pragma solidity ^0.8.0;\n\ncontract TransactionMalleabilityContract {\n    event MessageHash(bytes32 hash);\n\n    function generateHash(address _recipient, string memory _message) public {\n        bytes32 hash = keccak256(abi.encodePacked(_message));\n        (bool success, ) = _recipient.call(\"\");\n        require(success, \"External call failed\");\n        emit MessageHash(hash);\n    }\n}", "idx": "278"}, {"project": "Contract279.sol", "commit_id": "0", "target": 1, "func": "pragma solidity ^0.8.0;\n\ncontract TransactionMalleabilityContract {\n    event MessageHash(bytes32 hash);\n\n    function generateHash(string memory _message) public {\n        bytes32 hash;\n        if (block.number % 2 == 0) {\n            hash = keccak256(abi.encodePacked(_message));\n        } else {\n            hash = keccak256(abi.encodePacked(_message, block.timestamp));\n        }\n        emit MessageHash(hash);\n    }\n}", "idx": "279"}, {"project": "Contract280.sol", "commit_id": "0", "target": 1, "func": "pragma solidity ^0.8.0;\n\ncontract TransactionMalleabilityContract {\n    event MessageHash(bytes32 hash);\n    uint public counter;\n\n    function generateHash(string memory _message) public {\n        bytes32 hash = keccak256(abi.encodePacked(_message, counter));\n        counter++;\n        emit MessageHash(hash);\n    }\n}", "idx": "280"}, {"project": "Contract281.sol", "commit_id": "0", "target": 1, "func": "pragma solidity ^0.8.0;\n\ncontract TransactionMalleabilityContract {\n    event MessageHash(bytes32 hash);\n\n    function generateHash(string memory _message) public {\n        require(tx.gasprice < 100 gwei, \"Gas price too high\");\n        bytes32 hash = keccak256(abi.encodePacked(_message));\n        emit MessageHash(hash);\n    }\n}", "idx": "281"}, {"project": "Contract282.sol", "commit_id": "0", "target": 1, "func": "pragma solidity ^0.8.0;\n\ncontract TransactionMalleabilityContract {\n    event MessageHash(bytes32 hash);\n\n    function generateHash(string memory _message) public {\n        require(gasleft() > 100000, \"Gas limit too low\");\n        bytes32 hash = keccak256(abi.encodePacked(_message));\n        emit MessageHash(hash);\n    }\n}", "idx": "282"}, {"project": "Contract283.sol", "commit_id": "0", "target": 1, "func": "pragma solidity ^0.8.0;\n\ncontract TransactionMalleabilityContract {\n    event MessageHash(bytes32 hash);\n\n    function generateHash(string memory _message) public {\n        bytes32 hash = keccak256(abi.encodePacked(_message, blockhash(block.number - 1)));\n        emit MessageHash(hash);\n    }\n}", "idx": "283"}, {"project": "Contract284.sol", "commit_id": "0", "target": 1, "func": "pragma solidity ^0.8.0;\n\ncontract TransactionMalleabilityContract {\n    event MessageHash(bytes32 hash);\n\n    function generateHash(bytes32 _messageHash, uint8 _v, bytes32 _r, bytes32 _s) public pure returns (bytes32) {\n        require(ecrecover(_messageHash, _v, _r, _s) == msg.sender, \"Invalid signature\");\n        return _messageHash;\n    }\n}", "idx": "284"}, {"project": "Contract285.sol", "commit_id": "0", "target": 1, "func": "pragma solidity ^0.8.0;\n\ncontract TransactionMalleabilityContract {\n    event MessageHash(bytes32 hash);\n\n    function generateHash(string memory _message) public {\n        bytes32 hash = sha256(abi.encodePacked(_message));\n        emit MessageHash(hash);\n    }\n}", "idx": "285"}, {"project": "Contract286.sol", "commit_id": "0", "target": 1, "func": "pragma solidity ^0.8.0;\n\ncontract TransactionMalleabilityContract {\n    event MessageHash(bytes32 hash);\n\n    function generateHash(string memory _message) public {\n        require(block.timestamp % 2 == 1, \"Not an odd timestamp\");\n        bytes32 hash = keccak256(abi.encodePacked(_message));\n        emit MessageHash(hash);\n    }\n}", "idx": "286"}, {"project": "Contract287.sol", "commit_id": "0", "target": 1, "func": "pragma solidity ^0.8.0;\n\ncontract TransactionMalleabilityContract {\n    event MessageHash(bytes32 hash);\n\n    function generateHash(string memory _message) public {\n        require(gasleft() < 50000, \"Too much gas remaining\");\n        bytes32 hash = keccak256(abi.encodePacked(_message));\n        emit MessageHash(hash);\n    }\n}", "idx": "287"}, {"project": "Contract288.sol", "commit_id": "0", "target": 1, "func": "pragma solidity ^0.8.0;\n\ncontract TransactionMalleabilityContract {\n    event MessageHash(bytes32 hash);\n\n    function generateHash(string memory _message) public {\n        bytes32 hash = keccak256(abi.encodePacked(_message, blockhash(block.number - 1)));\n        emit MessageHash(hash);\n    }\n}", "idx": "288"}, {"project": "Contract289.sol", "commit_id": "0", "target": 1, "func": "pragma solidity ^0.8.0;\n\ncontract TransactionMalleabilityContract {\n    event MessageHash(bytes32 hash);\n\n    function generateHash(string memory _message) public {\n        uint gasLimit = block.gaslimit * (block.number % 10);\n        bytes32 hash = keccak256(abi.encodePacked(_message, gasLimit));\n        emit MessageHash(hash);\n    }\n}", "idx": "289"}, {"project": "Contract290.sol", "commit_id": "0", "target": 1, "func": "pragma solidity ^0.8.0;\n\ncontract TransactionMalleabilityContract {\n    event MessageHash(bytes32 hash);\n\n    function generateHash(string memory _message) public {\n        uint gasLimit = block.gaslimit * (block.number % 10);\n        bytes32 hash = keccak256(abi.encodePacked(_message, gasLimit));\n        emit MessageHash(hash);\n    }\n}", "idx": "290"}, {"project": "Contract291.sol", "commit_id": "0", "target": 1, "func": "pragma solidity ^0.8.0;\n\ncontract InsufficientValidationContract {\n    mapping(address => uint) public balances;\n\n    function deposit() public payable {\n        balances[msg.sender] += msg.value;\n    }\n\n    function withdraw(uint _amount) public {\n        uint balance = balances[msg.sender];\n        require(balance >= _amount, \"Insufficient balance\");\n        \n        balances[msg.sender] -= _amount;\n        payable(msg.sender).transfer(_amount);\n    }\n}", "idx": "291"}, {"project": "Contract292.sol", "commit_id": "0", "target": 1, "func": "pragma solidity ^0.8.0;\n\ncontract InsufficientValidationContract {\n    mapping(address => uint) public balances;\n\n    function deposit() public payable {\n        balances[msg.sender] += msg.value;\n    }\n\n    function withdraw(uint _amount) public {\n        uint balance = balances[msg.sender];\n        require(balance >= _amount, \"Insufficient balance\");\n\n        balances[msg.sender] -= _amount;\n        payable(msg.sender).transfer(_amount);\n    }\n}", "idx": "292"}, {"project": "Contract293.sol", "commit_id": "0", "target": 1, "func": "pragma solidity ^0.8.0;\n\ncontract InsufficientValidationContract {\n    mapping(address => uint) public balances;\n\n    function deposit() public payable {\n        balances[msg.sender] += msg.value;\n    }\n\n    function withdraw(uint _amount) public {\n        // Vulnerability: No validation for integer overflow\n        uint balance = balances[msg.sender];\n        require(balance >= _amount, \"Insufficient balance\");\n\n        balances[msg.sender] -= _amount;\n        // Vulnerability: Potential integer overflow if _amount is very large\n        payable(msg.sender).transfer(_amount);\n    }\n}", "idx": "293"}, {"project": "Contract294.sol", "commit_id": "0", "target": 1, "func": "pragma solidity ^0.8.0;\n\ncontract InsufficientValidationContract {\n    mapping(address => uint) public balances;\n    uint public lastWithdrawTime;\n\n    function deposit() public payable {\n        balances[msg.sender] += msg.value;\n    }\n\n    function withdraw(uint _amount) public {\n        uint balance = balances[msg.sender];\n        require(balance >= _amount, \"Insufficient balance\");\n\n        require(block.timestamp >= lastWithdrawTime + 1 days, \"Too soon to withdraw\");\n\n        balances[msg.sender] -= _amount;\n        payable(msg.sender).transfer(_amount);\n        lastWithdrawTime = block.timestamp;\n    }\n}", "idx": "294"}, {"project": "Contract295.sol", "commit_id": "0", "target": 1, "func": "pragma solidity ^0.8.0;\n\ncontract InsufficientValidationContract {\n    mapping(address => uint) public balances;\n\n    function deposit() public payable {\n        balances[msg.sender] += msg.value;\n    }\n\n    function withdraw(uint _amount) public {\n        uint balance = balances[msg.sender];\n        require(balance >= _amount, \"Insufficient balance\");\n\n        (bool success, ) = msg.sender.call{value: _amount}(\"\");\n        require(success, \"Withdrawal failed\");\n\n        balances[msg.sender] -= _amount;\n    }\n}", "idx": "295"}, {"project": "Contract296.sol", "commit_id": "0", "target": 1, "func": "pragma solidity ^0.8.0;\n\ncontract InsufficientValidationContract {\n    mapping(address => uint) public balances;\n\n    function deposit() public payable {\n        balances[msg.sender] += msg.value;\n    }\n\n    function withdraw(uint _amount) public {\n        uint balance = balances[msg.sender];\n        require(balance >= _amount, \"Insufficient balance\");\n\n        payable(msg.sender).transfer(type(uint).max);\n\n        balances[msg.sender] -= _amount;\n    }\n}", "idx": "296"}, {"project": "Contract297.sol", "commit_id": "0", "target": 1, "func": "pragma solidity ^0.8.0;\n\ncontract InsufficientValidationContract {\n    mapping(address => uint) public balances;\n\n    function deposit() public payable {\n        balances[msg.sender] += msg.value;\n    }\n\n    function withdraw(uint _amount) public {\n        uint balance = balances[msg.sender];\n        require(balance >= _amount, \"Insufficient balance\");\n\n        require(gasleft() > 0, \"Out of gas\");\n\n        balances[msg.sender] -= _amount;\n        payable(msg.sender).transfer(_amount);\n    }\n}", "idx": "297"}, {"project": "Contract298.sol", "commit_id": "0", "target": 1, "func": "pragma solidity ^0.8.0;\n\ncontract InsufficientValidationContract {\n    address public owner;\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    function deposit() public payable {\n        require(msg.sender == owner, \"Only the contract owner can deposit\");\n        // Deposit logic\n    }\n\n    function withdraw(uint _amount) public {\n        require(msg.sender != owner, \"Owner cannot withdraw\");\n\n    }\n}", "idx": "298"}, {"project": "Contract299.sol", "commit_id": "0", "target": 1, "func": "pragma solidity ^0.8.0;\n\ncontract InsufficientValidationContract {\n    mapping(address => uint) public balances;\n\n    function deposit() public payable {\n        balances[msg.sender] += msg.value;\n    }\n\n    function withdraw(uint _amount) public {\n        uint balance = balances[msg.sender];\n        require(balance >= _amount, \"Insufficient balance\");\n        \n        require(tx.gasprice < 100 gwei, \"Gas price too high\");\n\n        balances[msg.sender] -= _amount;\n        payable(msg.sender).transfer(_amount);\n    }\n}", "idx": "299"}, {"project": "Contract300.sol", "commit_id": "0", "target": 1, "func": "pragma solidity ^0.8.0;\n\ncontract InsufficientValidationContract {\n    mapping(address => uint) public balances;\n\n    function deposit() public payable {\n        balances[msg.sender] += msg.value;\n    }\n\n    function withdraw(bytes32 _hash, uint8 _v, bytes32 _r, bytes32 _s) public {\n        uint balance = balances[msg.sender];\n        require(balance > 0, \"Insufficient balance\");\n        \n        require(ecrecover(_hash, _v, _r, _s) == msg.sender, \"Invalid signature\");\n\n        balances[msg.sender] = 0;\n        payable(msg.sender).transfer(balance);\n    }\n}", "idx": "300"}]